---
title: "Spatial modelling of the two-party preferred vote in Australian federal elections: 2001--2016"
author: Jeremy Forbes$^*$, Dianne Cook, Rob J Hyndman
toc: false
documentclass: anzsauth
classoption: times, doublespace
fontfamily: times
bibliography: references.bib
biblio-style: anzsj
output:
  bookdown::pdf_document2:
    fig_caption: yes
    citation_package: natbib
    keep_tex: yes
    number_sections: yes
    fig_height: 5
    fig_width: 8
    includes:
      in_header: anzjs_preamble.tex
---

# Summary {-}

We examine the relationships between electoral socio-demographic characteristics and two-party preferences in the six Australian federal elections held between 2001 and 2016. Socio-demographic information is derived from the Australian Census which occurs every five years. Since a census is not directly available for each election, an imputation method is employed to estimate census data for the electorates at the time of each election. This accounts for both spatial and temporal changes in electoral characteristics between censuses. To capture any spatial heterogeneity, a spatial error model is estimated for each election, which incorporates a spatially structured random effect vector. Over time, the impact of most socio-demographic characteristics that affect electoral two-party preference do not vary, with age distribution, industry of work, incomes, household mobility and relationships having strong effects in each of the six elections. Education and unemployment are amongst those that have varying effects. All data featured in this study has been contributed to the \textsf{eechidna} \textsf{R} package (available on CRAN).

**Keywords:** federal election, census, Australia, spatial modelling, imputation, data science, socio-demographics, electorates, R, eechidna

# Introduction {#intro}

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  fig.pos = "h",
  fig.align = "center",
  cache = TRUE,
  message = FALSE
)
library(tidyverse)
library(eechidna)
library(forcats)
library(ggthemes)
library(knitr)
library(nlme)
library(rgeos)
library(spdep)
library(patchwork)
library(predictmeans)
source("functions.R")
```

```{r temporary_load_local_data, include = FALSE}
load("data/abs2004_cd.rda")
load("data/abs2007_cd.rda")
load("data/abs2010_cd.rda")
load("data/abs2013_cd.rda")
```

```{r wrangle, include = FALSE}
# Take log of indigenous, judaism, islam, buddhism
abs2016 <- eechidna::abs2016 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2013 <- abs2013_cd %>% #eechidna::abs2013 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2010 <- abs2010_cd %>% #eechidna::abs2010 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2007 <- abs2007_cd %>% #eechidna::abs2007 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2004 <- abs2004_cd %>% #eechidna::abs2004 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2001 <- eechidna::abs2001 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )

# Change abs2016 to data frame to prevent error below
abs2016 <- as.data.frame(abs2016)

# Combine and standardise
my_df <- bind_rows(
  left_join(eechidna::tpp01,
    standardise_vars(abs2001) %>%
      dplyr::select(-c(UniqueID, Area, ends_with("NS"), Population)),
    by = c("DivisionNm", "StateAb" = "State")
  ) %>% mutate(year = "2001"),
  left_join(eechidna::tpp04,
    standardise_vars(abs2004),
    by = c("DivisionNm")
  ) %>% mutate(year = "2004"),
  left_join(eechidna::tpp07,
    standardise_vars(abs2007),
    by = c("DivisionNm")
  ) %>% mutate(year = "2007"),
  left_join(eechidna::tpp10,
    standardise_vars(abs2010),
    by = c("DivisionNm")
  ) %>% mutate(year = "2010"),
  left_join(eechidna::tpp13,
    standardise_vars(abs2013),
    by = c("DivisionNm")
  ) %>% mutate(year = "2013"),
  left_join(eechidna::tpp16,
    standardise_vars(abs2016) %>%
      dplyr::select(-c(UniqueID, Area, ends_with("NS"), Population)),
    by = c("DivisionNm", "StateAb" = "State")
  ) %>% mutate(year = "2016")
) %>%
  mutate(year = factor(year),
    Band_00_19 = Age00_04 + Age05_14 + Age15_19,
    Band_20_34 = Age20_24 + Age25_34,
    Band_35_54 = Age35_44 + Age45_54,
    Band_55plus = Age55_64 + Age65_74 + Age75_84 + Age85plus) %>%
  dplyr::select(-c(
    starts_with("Age"), MedianAge, StateAb,
    LNP_Votes, ALP_Votes, ALP_Percent, TotalVotes, Swing,
    InternetUse, InternetAccess, EnglishOnly,
    Other_NonChrist, OtherChrist, Catholic, Anglican,
    Volunteer, EmuneratedElsewhere, Population, UniqueID
  ))

# Create final df for modelling

factors_df <- my_df %>%
  mutate(
    Education = BachelorAbv + HighSchool + Professional + Finance - Laborer - Tradesperson - DipCert,
    FamHouseSize = FamilyRatio + AverageHouseholdSize + Couple_WChild_House - Couple_NoChild_House - SP_House,
    PropertyOwned = Owned + Mortgage - Renting - PublicHousing,
    RentLoanPrice = MedianRent + MedianLoanPay,
    Incomes = MedianFamilyIncome + MedianHouseholdIncome + MedianPersonalIncome,
    Unemployment = Unemployed - LFParticipation
  ) %>%
  dplyr::select(-c(
    BachelorAbv, HighSchool, Professional, Finance, Laborer, Tradesperson, DipCert, FamilyRatio,
    AverageHouseholdSize, Couple_WChild_House, Couple_NoChild_House, SP_House, Owned, Mortgage, Renting,
    PublicHousing, MedianFamilyIncome, MedianHouseholdIncome, MedianPersonalIncome, MedianRent,
    MedianLoanPay, Unemployed, LFParticipation
  ))

# Now standardise factors

small_df <- bind_rows(
  factors_df %>% filter(year == "2001") %>% standardise_vars(),
  factors_df %>% filter(year == "2004") %>% standardise_vars(),
  factors_df %>% filter(year == "2007") %>% standardise_vars(),
  factors_df %>% filter(year == "2010") %>% standardise_vars(),
  factors_df %>% filter(year == "2013") %>% standardise_vars(),
  factors_df %>% filter(year == "2016") %>% standardise_vars()
)

# Order electorates in alphabetical order to match spatial matrix
model_df <- small_df %>%
  arrange(year, DivisionNm) %>%
  dplyr::select(order(colnames(.))) %>%
  rename(
    ManagerAdmin = ManagerAdminClericalSales,
    OtherLanguage = OtherLanguageHome,
    BornSEEuro = Born_SE_Europe,
    BornAsia = Born_Asia,
    BornUK = Born_UK,
    BornMidEast = Born_MidEast,
    OneParentHouse = OneParent_House,
    Pop_00_19 = Band_00_19,
    Pop_20_34 = Band_20_34,
    Pop_35_54 = Band_35_54
  ) %>%
  dplyr::select(-Band_55plus)
```

```{r spatialweights, eval = FALSE}
# Get spatial weights
# This is not run, as weights are pulled from github, but this can be run to get them from scratch.
sF_16 <- sF_download(2016)
sF_13 <- sF_download(2013)
sF_10 <- sF_download(2010)
sF_07 <- sF_download(2007)
sF_04 <- sF_download(2004)
sF_01 <- sF_download(2001)

sp_weights_16 <- sp_weights_matrix(sF_16)
sp_weights_13 <- sp_weights_matrix(sF_13)
sp_weights_10 <- sp_weights_matrix(sF_10)
sp_weights_07 <- sp_weights_matrix(sF_07)
sp_weights_04 <- sp_weights_matrix(sF_04)
sp_weights_01 <- sp_weights_matrix(sF_01)
```

```{r FGLS, include = FALSE}
# Instead of running spatial weights, load from github
load("data/sp_weights_01.rda")
load("data/sp_weights_04.rda")
load("data/sp_weights_07.rda")
load("data/sp_weights_10.rda")
load("data/sp_weights_13.rda")
load("data/sp_weights_16.rda")

## Run full models for each year
full_formula <- "LNP_Percent ~ ."

# 2016
glsmod16 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2016"),
  sp_weights = sp_weights_16
)

# 2013
glsmod13 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2013"),
  sp_weights = sp_weights_13
)

# 2010
glsmod10 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2010"),
  sp_weights = sp_weights_10
)

# 2007
glsmod07 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2007"),
  sp_weights = sp_weights_07
)

# 2004
glsmod04 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2004"),
  sp_weights = sp_weights_04
)

# 2001
glsmod01 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2001"),
  sp_weights = sp_weights_01
)

## Visualise coefficients and significance

coef_df <- bind_rows(
  data.frame(
    variable = glsmod16$coefficients %>% names(),
    estimate = glsmod16$coefficients %>% unname(),
    se = summary(glsmod16)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod16)$tTable[, "p-value"] %>% unname(),
    year = 2016),
  data.frame(
    variable = glsmod13$coefficients %>% names(),
    estimate = glsmod13$coefficients %>% unname(),
    se = summary(glsmod13)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod13)$tTable[, "p-value"] %>% unname(),
    year = 2013),
  data.frame(
    variable = glsmod10$coefficients %>% names(),
    estimate = glsmod10$coefficients %>% unname(),
    se = summary(glsmod10)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod10)$tTable[, "p-value"] %>% unname(),
    year = 2010),
  data.frame(
    variable = glsmod07$coefficients %>% names(),
    estimate = glsmod07$coefficients %>% unname(),
    se = summary(glsmod07)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod07)$tTable[, "p-value"] %>% unname(),
    year = 2007),
  data.frame(
    variable = glsmod04$coefficients %>% names(),
    estimate = glsmod04$coefficients %>% unname(),
    se = summary(glsmod04)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod04)$tTable[, "p-value"] %>% unname(),
    year = 2004),
  data.frame(
    variable = glsmod01$coefficients %>% names(),
    estimate = glsmod01$coefficients %>% unname(),
    se = summary(glsmod01)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod01)$tTable[, "p-value"] %>% unname(),
    year = 2001)
)
```

Australia has changed in many ways over the last two decades. Rising house prices, country-wide improvements in education, an ageing population, and a decline in religious affiliation, are just a few facets of the country's evolving socio-demographic characteristics. At the same time, political power has moved back and forth between the two major parties. In the 2007 and 2010 federal elections, the Australian Labor Party (hereafter Labor) was victorious, whereas the 2001, 2004, 2013 and 2016 elections were won by the Liberal National coalition (hereafter Liberal). The two-party preferred vote, a measure of support between these two parties, fluctuated between 47.3% and 53.5% (in favour of the Liberal party) over this period. This study explores how electoral (aggregate) socio-demographic characteristics relate to two-party preferences, and whether their effects have changed over time.

The Australian Electoral Commission (AEC) divides Australia into 150 regions, called electorates, with each corresponding to a single seat in the House of Representatives. If a party wins a majority of seats, they become the governing party. Data on the socio-demographics of these electorates are derived from the Australian Census, and vote counts are obtained from Australian federal elections. Joining these two data sources is problematic as there is an inherent asynchronicity in the two types of events. A census is conducted by the Australian Bureau of Statistics (ABS) every five years, whereas federal elections, conducted by the AEC, usually occur every three years or so. The first problem addressed is that of constructing appropriate census data for the 2004, 2007, 2010 and 2013 elections---election years in which a census did not occur. The predominant approach in previous studies was to join voting outcomes to the nearest census, without accounting for any temporal differences [see @DavisStimson98;@Stimson06;@Liao09;@Stimson09]. Furthermore, electoral boundaries change regularly, so spatial discrepancies also arise when matching with electoral data. To obtain appropriate 'census-like' data for these four elections, electoral socio-demographics are constructed using a spatio-temporal imputation that combines areal interpolation [@Goodchild1993] and linear time-interpolation. Collecting and wrangling the raw data, along with the imputation process, are detailed in Section \@ref(data). All data and associated documentation relating to this procedure are available in the \textsf{eechidna} \textsf{R} package [@eechidna], providing a resource for any future analysis.

Previous work on modelling Australian federal elections has found that aggregate socio-demographics are relatively good predictors of voting outcomes. @Forrest01 used multiple regression to model the Liberal and Labor primary vote for polling booths in the Farrer electorate in 1998 as a function of census variables from 1996. @Stimson06, @Stimson09 and @Stimson12 used principal component analysis of polling booths in the 2001, 2004 and 2007 elections respectively, also finding that socio-demographic characteristics of polling booths are linked to their two-party preferred vote. In contrast, @Stimson09 models the polling booth swing vote (change in the two-party preferred vote) in the 2007 election, finding that little of the swing vote can be explained by census data.

Instead of analyzing a single election in isolation, this paper employs a consistent model framework across six elections so that temporal changes in the effects of socio-demographics can be observed. Each federal election is modelled with a cross-sectional dataset, where each observation is one of the 150 electorates. This dataset consists of the two-party preferred vote (as the response variable) and a set of common socio-demographic variables (as the explanatory variables).<!--The use of a regression framework to examine these socio-political relationships over time is seemingly absent from previous Australian studies. It also appears that no study has attempted any type of statistical analysis of socio-demographics in conjunction with voter behaviour in Australia since 2007, making this paper distinctly different from previous work.--> To prepare these datasets, socio-demographic variables are first standardised, and then a principal component analysis is used to group many of the variables into 'factors'. To account for the inherent spatial structure of the data, a spatial error model is then estimated for each election. In interpreting these models, it is important to be mindful of the ecological fallacy. Insights are being drawn at the electorate level and cannot be inferred for another disaggregate level (in particular, drivers of individual voter behaviour may vary from what is observed at the electorate level).

The paper is organised as follows. Section \@ref(data) describes the data collection, joining and cleaning, while model details are discussed in Section \@ref(modelling). Section \@ref(results) describes the inference conducted to determine significance of effects and how these change over time, as well as including details on model robustness. Section \@ref(conclusion) summarises the work. Two supplementary sections document the contributions of others to this work and the software.

# Data collection, wrangling and imputation {#data}

## Collecting the data

The voting outcome of interest is the electoral two-party preferred vote, which is provided by the Australian Electoral Commission (AEC) for the 2001, 2004, 2007, 2010, 2013 and 2016 elections via the AEC Tally Room. The AEC divides Australia into 150 regions, called electorates, with each corresponding to a single seat in the House of Representatives. Voting is compulsory in Australia, and each voter assigns a numbered preference to each available candidate in their electorate. The two-party preferred vote is determined by a tally of these preferences where, by convention, only the ranks of the Labor and Liberal candidates are considered. This is recorded as a percentage preference in favour of the Liberal party.

Socio-demographic variables are derived from the Australian Census of Population and Housing (census), which is a survey of every household in Australia, recording information such as age, gender, ethnicity, education level and income. There have been four censuses so far in the 21st century, conducted in 2001, 2006, 2011 and 2016. The Australian Bureau of Statistics (ABS) conducts the census and publishes aggregated information. The ABS uses electoral boundaries as defined by the AEC at the time of each census, which may not match those in place at the subsequent and previous elections. From the available census information aggregated at the electorate level, 50 socio-demographic variables are defined for each of the electorates to be used in the analysis. These variables include information relating to electoral age distributions, income, education qualifications, employment industries and job types, religion, birthplace, household characteristics and relationships.

Raw data is sourced online from the AEC and ABS websites in \textsf{.csv} and \textsf{.xlsx} files. The formats of these files differ over the years, making extracting the appropriate information a big task. The functions available in the \textsf{dplyr} [@dplyr] and \textsf{readxl} [@readxl] \textsf{R} packages are particularly useful, as they provide fast consistent tools for data manipulation and functions to import \textsf{.xlsx} files. The 2001 and 2006 census data are published in a format where the information for each electorate is held in a separate document making it difficult to use the \textsf{dplyr} tools. Instead, cells have to be selected from each individual file to construct the desired variables. All scripts required for the data wrangling process can be found in the github repository for the \textsf{eechidna} \textsf{R} package [@eechidna], along with the raw data. The \textsf{eechidna} package makes this study entirely reproducible and provides a resource to help wrangle data for future censuses and elections, when they become available.

## Joining census and election data

### Differences between census and election data {-}

Between 2001 and 2016 there were six elections and four censuses (see Figure \@ref(fig:timeline)). Electoral boundaries are redistributed regularly by the AEC, meaning that only in the years where both a census and an election occur are all boundaries likely to match---the case for the 2001 and 2016 elections. Therefore, for the four elections between 2004 and 2013, both temporal and spatial differences in electorates need to be accounted for when joining the electoral two-party preferred vote with census data. For these elections a spatio-temporal imputation method is employed to obtain electoral socio-demographics. This method uses census information from both before and after the election of interest.

```{r timeline, echo = FALSE, fig.cap="Timeline of Australian elections and censuses. They do not always occur in the same year.", out.width = "90%", fig.align="center"}
timeline <- data.frame(year = c(2001:2016)) %>%
  mutate(
    Election = ifelse(year %in% c(2001, 2004, 2007, 2010, 2013, 2016), 1, 0),
    Census = ifelse(year %in% c(2001, 2006, 2011, 2016), 1.4, 0)
  ) %>%
  gather(c(Election, Census), key = event, value = measure) %>%
  filter(measure != 0) %>%
  mutate(year_vis = ifelse(event == "Census", year + 0.1, year))

ggplot(timeline, aes(x = year_vis, y = measure)) +
  geom_point(aes(color = as.factor(event), shape = as.factor(event)), size = 4) +
  labs(color = "Event", shape = "Event", x = "Year") +
  geom_hline(yintercept = 0, size = 1, color = "grey", show.legend = FALSE) +
  geom_segment(x = 2001, xend = 2001, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2004, xend = 2004, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2007, xend = 2007, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2010, xend = 2010, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2013, xend = 2013, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2016, xend = 2016, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2001.1, xend = 2001.1, y = 1.4, yend = 0, color = "#F8766D") +
  geom_segment(x = 2006.1, xend = 2006.1, y = 1.4, yend = 0, color = "#F8766D") +
  geom_segment(x = 2011.1, xend = 2011.1, y = 1.4, yend = 0, color = "#F8766D") +
  geom_segment(x = 2016.1, xend = 2016.1, y = 1.4, yend = 0, color = "#F8766D") +
  theme(
    text = element_text(size = 10),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    plot.background = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank()
  ) +
  scale_x_discrete(limits = c(2001:2016)) +
  coord_fixed(ratio = 2)
```

### Spatio-temporal imputation {-}

For each election, neighbouring census information has to be combined in some way so that it represents the boundaries in place at the time of the election. This is done by taking the electoral boundaries and imputing the corresponding socio-demographic characteristics for each of the neighbouring censuses, thereby addressing the spatial aspect. Next, to deal with the temporal component, characteristics at the time of the election are constructed using linear interpolation between the spatially imputed neighbouring census variables.

The finest level of disaggregation available for census data is the region classification called Statistical Area 1 (SA1). In 2016, Australia was divided into over 55,000 SA1s. Consider each of these SA1 regions as a source zone, $s = 1,\dots,S$, for which socio-demographic information is available. For simplicity, let each source zone be wholly summarised by its centroid. A set of target zones, $t = 1,\dots,T$, are defined as regions for which information is to be imputed---these are the electoral boundaries for a particular election.

Take the example of the Melbourne Ports electorate from the 2013 federal election, illustrated in Figure \@ref(fig:melbports13). The purple region in this figure represents the target zone and the source zones are the centroid locations from the 2016 census SA1 areas.

```{r melbports13, fig.cap = "The electoral boundaries for Melbourne Ports (shown in purple) and surrounding electorates, with centroids for Statistical Area 1 regions from the 2016 census overlaid. The centroids falling within the purple region are attributed to Melbourne Ports.", out.height="28%"}
# Get Vic shape
load("data/vic_map.rda")
load("data/MP_sa1_dots_2011.rda")

p1 <- ggplot(data = vic_map) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = Elect_div == "Melbourne Ports"),
    colour = "black", alpha = 0.4
  ) +
  scale_fill_manual(
    name = "Electoral Boundaries",
    values = c("white", "purple"),
    labels = c("Other Electorates", "Melbourne Ports (VIC)")
  ) +
  theme_map() +
  coord_equal(xlim = c(144.88, 145.07), ylim = c(-37.92, -37.78))

p1 + geom_point(aes(x = long_c, y = lat_c, shape = shape), data = MP_sa1_dots_2011 %>% mutate(shape = "1"), colour = "grey25", size = 1.3) + scale_shape_manual(name = "Statistical Area 1", values = 3, labels = "Centroids")
```

Furthermore, let $I_{s,t}$ be an indicator variable, for which $I_{s,t} = 1$ if the centroid of source zone $s$ falls within target zone $t$, and $0$ otherwise. Additionally, let the population of the source zone $s$ be $P_{s}$.

In order to calculate socio-demographic information for each of the target zones, a weighted average of source zones is taken using their populations as weights. Denote a given census variable for the target zone by $C_t$, and the same census variable for the source zone as $D_s$. Then, estimate $C_t$ using
$$
  \hat{C}_t = \frac{\sum_{s=1}^{S}{I_{s,t} \times D_s \times P_s}}%
  {\sum_{s=1}^{S}{I_{s,t} \times P_s}},
  \quad\text{for each $t=1,\dots,T$}.
$$

This concludes the spatial imputation of the socio-demographic characteristics for one target zone (a single electoral boundary), at the time of only one of the neighbouring censuses. This process is repeated for all of the target zones, and then for the other neighbouring census.

\enlargethispage*{0.5cm}

To account for temporal changes, linear interpolation is used between census years to get the final estimate of a census variable for the target zone in the election year. Let $y_1$ be the year of the census preceding an election, let $y_2$ be the year of the election, and $y_3$ be the year of the census that follows. Add this year subscript to the census variable estimate $\hat{C}_t$, resulting in $\hat{C}_{t,y}$. Linear interpolating between these census years results an imputed value for the election year, given by
$$
  \hat{C}_{t,y_2} = \frac{y_3-y_2}{y_3-y_1} \hat{C}_{t,y_1} +
    \frac{y_2-y_1}{y_3-y_1} \hat{C}_{t,y_3}.
$$
Implicitly this assumes that population characteristics change in a linear manner over time.

Continuing with the example of Melbourne Ports in the 2013 election, the estimate for a given census variable in 2016, $\hat{C}_{\text{MelbPorts}, 2016}$ would be obtained by computing the weighted average of this variable amongst the SA1s within the purple region shown in Figure \@ref(fig:melbports13). This would be repeated with the 2011 census SA1s to obtain $\hat{C}_{\text{MelbPorts}, 2011}$, from which the final estimate is given by
$$
  \hat{C}_{\text{MelbPorts},2013}
    = \frac{3}{5} \hat{C}_{\text{MelbPorts},2011} + \frac{2}{5} \hat{C}_{\text{MelbPorts},2016}.
$$
This is done for each of the socio-demographic variables, and is repeated for each of the 149 remaining target zones corresponding with 2013 electorates.

# Modelling {#modelling}

From this imputation process, electoral socio-demographic variables are available for each of the six elections and can be joined with their corresponding two-party preferred votes. Before choosing an appropriate model, two issues with the socio-demographic variables need to be addressed. First, variable scales change over the years, making it important to standardise variables. Second, many variables represent similar information and where appropriate, will be grouped together. To determine which variables should be grouped, principal component analysis (PCA) is used to guide the construction of specific factors. The intuition here is that PCA will identify which variables covary, from which intuitive groupings of variables can be chosen to combine into individual variables. Details are given in Section 3.2. After these steps, a model specification is chosen. 

## Standardizing variables

Many of the socio-demographic variables have changing scales over the years. For example, inflation-adjusted median rental prices increased across almost all electorates, with median rent of 225 dollars per week placing an electorate in the 90th percentile in 2001, but only the 45th percentile in 2016. In order for socio-demographic effects to be comparable across years, all explanatory variables are standardised to have mean zero and variance one within each election year. By standardizing, each variable is reported as a relative measure compared to all other electorates in the same year. (Note that the log values were standardised for the variables `Judaism`, `Indigenous`, `Islam` and `Buddhism`.)

## Creating factors

There are only $N = 150$ observations (electorates) in each election and $p = 50$ socio-demographic variables in each cross-section, with many variables representing similar information about an electorate. Any model that uses all variables would face problems with multi-collinearity and over-fitting, which would likely lead to erroneous conclusions regarding variable significance. To address this, a subset of variables that represent similar information are combined into a single variable, which will be referred to as a 'factor'.

A factor is created from a group of variables if there is an intuitive reason as to why these variables should represent similar information and if there is evidence to suggest that they covary. For example, a potential group would be variables relating to electoral incomes---median family, household and personal incomes. To determine which variables covary, principal component analysis is used on a combined dataset of socio-demographic variables from all six elections. The only variables exempted from the principal component analysis are the four variables representing age brackets (the proportion of the population aged 0--19 years old, 20--34 years old, 45--54 years old and 55 years plus), which are included in the model as separate variables.

Only the first four principal components from the combined dataset are considered, as the scree plot levels off after the fourth component. Variables that have a large loading in a particular component are deemed to covary, with a loading with magnitude greater than 0.15 being considered large. Each principal component is considered separately. If a subset of variables have large loadings (positive or negative) in a given component, and there is an intuitive reason as to why they should be grouped together, then this subset of variables will be combined to become a factor. Note that more than one factor can be deduced from a principal component (i.e.\ multiple non-overlapping subsets of variables), and that any variables not included in a factor are not discarded.

Six factors are created using this approach. These are:
`Incomes` (median personal income, median household income, median family income);
`Unemployment` (unemployment rate, labour force participation rate);
`PropertyOwned` (proportion of dwellings that are owned, proportion of dwellings that are mortgages, proportion of dwellings that are rented, proportion of dwellings that classified as government housing);
`RentLoanPrice` (median rental payment amount, median loan repayment amount);
`FamHouseSize` (average household size, ratio of people to families, incidence of single person households, incidence of households containing a couple with kids, incidence of households containing a couple without kids); and
`Education` (high school completions, undergraduate and postgraduate degrees, proportion of employed people working as professionals, proportion of jobs in finance, proportion of workers who are labourers, proportion of workers who work as a tradesperson, diploma and certificate qualifications).

For each of these groupings, a factor is created by taking a weighted sum of the variables. The weightings are allocated on the basis of whether the variable had a positive or negative loading in the principal component from which the grouping was identified. Variables with a positive loading are allocated a weight of $+1$ and those with negative loadings are allocated a weight of $-1$. After computing these weighted sums, the factor is standardised to have mean zero and variance one, within each election.

The final predictor set contains $p=32$ variables which are listed in Table \ref{tab:printmodels}. (Note that the factor creation procedure reduces the variable set to $p=33$, however the `Pop_55_plus` age bracket is not included as a variable to avoid multicollinearity, because the other three age brackets are included.)

## Regression incorporating spatially dependent errors

An identical model specification is used for each of the six elections, with each election modelled separately. Separate models are preferred to a single model because of how frequently electoral boundaries change, noting that electorates with the same name across elections are not guaranteed to represent the same geographic region. Therefore any fixed or random effects models would be difficult to estimate without implementing consistent boundaries, which would require further imputation (of voting information). The separate models also allow the socio-demographic effects to be estimated separately for each election year, facilitating analysis of temporal changes in variable effects. This can be considered a special case of a longitudinal model where all coefficients are time-varying and heteroskedasticity is time-varying.

For each cross-section, let the response $\bm{y}$ be the vector two-party preferred vote in favour of the Liberal party; for example, $y_i = 70$ represents a 70% preference for Liberal, 30% for Labor, in electorate $i$. Although $y_i$ lies in the interval $(0,100)$, observed values are never close to 0 or 100 (minimum $24.05 \%$ and maximum $74.90 \%$), so there is no need to formally impose the constraint of $y_i \in [0,100]$. Furthermore, the responses are found to be spatially correlated in each election (Moran's I test, $p \le 7\cdot10^{-15}$). This is not surprising as electorates are aggregate spatial units, and hence the spatial structure of the data must be modelled appropriately.

The spatial error model [@Anselin88] is chosen because it captures spatial heterogeneity by incorporating a spatially structured random effect vector [@LeSage2009]. In this context, the random effect can be thought of as capturing the effect of any characteristics that neighbourhoods share that have not been addressed by the independent variables included in the model.

```{r printmodels, warning=FALSE, message=FALSE, include=FALSE}
# Add rho and GLS residual standard error
regtable <- stargazer::stargazer(
  glsmod01, glsmod04, glsmod07, glsmod10, glsmod13, glsmod16,
  header = FALSE,
  column.sep.width = "1pt",
  no.space=TRUE,
  model.numbers=FALSE,
  keep.stat = c("n","ser"),
  dep.var.caption="",
  dep.var.labels="\\vspace{-0.4cm}",
  title = "Estimated spatial error model parameters (standard errors) for each of the six election years.\\vspace*{-0.4cm}",
  #dep.var.labels = "Two-party preferred vote in favour of the Liberal party",
  font.size = "scriptsize",
  digits = 2,
  column.labels = c("2001", "2004", "2007", "2010", "2013", "2016"),
  label="tab:printmodels"
  #notes = c("Estimated coefficients for variable named in column one shown for", "election year indicated by column heading, with estimated standard", "deviation for each coefficient shown below in parenthesis. Overall", "summary measures for each regression equation are provided in the", "bottom panel."),
  #notes.align = "l"
)
# Add correlations
getrho <- function(x, element) {x$rho_df[[element]]}
rho <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getrho, element="estimate")
rhop <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getrho, element="p")
rhose <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getrho, element="se")
rholine1 <- paste("$\\rho$",
            paste(" & ",
                  sprintf("%3.2f",rho),
                  ifelse(rhop < 0.01, "$^{***}$",
                  ifelse(rhop < 0.05, "$^{**}$",
                  ifelse(rhop < 0.10, "$^{*}$",""))),
              sep="", collapse=""),
            "\\\\", sep="", collapse="")
rholine2 <- paste("",
            paste(" & (",
                  sprintf("%3.2f",rhose), ")",
              sep="", collapse=""),
            "\\\\", sep="", collapse="")
regtable <- c(regtable[1:11], rholine1, rholine2, regtable[12:length(regtable)])
# Add residual standard error (GLS)
getsigma <- function(x, element) {x$sigma}
sigma <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getsigma)
sigmaline <- paste("Residual Standard Error (GLS)",
             paste(" & ",
                   sprintf("%4.2f", sigma),
                   sep="", collapse=""),
             "\\\\", sep="", collapse="")
regtable <- c(regtable[1:79],sigmaline, regtable[80:length(regtable)])
# Squeeze some more space
regtable[2] <- "\\begin{table}[!htbp]\\vspace*{-0.4cm}\\centering "
# Allow alignment on decimal point
regtable[6] <- "\\begin{tabular}{@{\\extracolsep{1pt}}lrrrrrr}"
regtable[12:80] <- gsub(")","\\\\rlap{)}",regtable[12:80])
regtable[12:80] <- gsub("$^{*}$","\\rlap{$^{*}$}", regtable[12:80], fixed=TRUE)
regtable[12:80] <- gsub("$^{**}$","\\rlap{$^{**}$}", regtable[12:80], fixed=TRUE)
regtable[12:80] <- gsub("$^{***}$","\\rlap{$^{***}$}", regtable[12:80], fixed=TRUE)
# Column spacing
regtable[5] <- "\\fontsize{7}{8}\\rm\\tabcolsep=0.42cm"
# Remove "Note"
regtable[85] <- "& \\multicolumn{6}{r}{$^{*}$p$<$0.1; $^{**}$p$<$0.05; $^{***}$p$<$0.01} \\\\"
```

```{r printmodels2, results='asis', dependson='printmodels'}
cat(regtable)
```

Spatial weights are calculated in accordance with the assumption that an electorate is equally correlated with any electorate that shares a part of its boundary. Let $\rho$ be the spatial autoregressive coefficient, $\bm{v}$ be a spherical error term, $\bm{W}$ be a matrix of spatial weights (containing information about the neighbouring regions), $\bm{X}$ be a matrix of socio-demographic covariates, $\bm{\beta}$ be a vector of regression coefficients and $\bm{a}$ be a spatially structured random effect vector.

Let
$$
  \bm{y} = \bm{X} \bm{\beta} + \bm{a},
$$
and
$$
  \bm{a} = \rho \bm{W} \bm{a} + \bm{v},
$$
where $\bm{v} \sim N(\bm{0}, \sigma^2 \bm{I_n})$, and hence
$$
  \bm{y} = \bm{X} \bm{\beta} + (\bm{I}_n-\rho \bm{W})^{-1}\bm{v}.
$$
Estimation of the above spatial error model is undertaken using feasible generalised least squares.

Table \@ref(tab:printmodels) details the estimated model coefficients and their estimated standard errors, for each of the six elections. An interpretation of these estimated values is provided in the next section.

# Results

## Spatial autoregressive parameter

The spatial autoregressive coefficient $\rho$ was positive and significant in the 2001, 2004 and 2016 elections (Figure \@ref(fig:rhovis)). In these three elections, there is evidence to suggest that neighbours shared some influential characteristics outside the explanatory variables, which affected the two-party preferred vote. Conversely, in the other three elections, the spatial effect is weaker and insignificant (although still positive).

```{r rhovis, fig.cap="Estimates of the spatial autoregressive parameter for each of the six elections, reported with their individual 95\\% confidence intervals. In 2001, 2004 and 2016 there is a significant spatial component.", out.height='25%', out.extra = ''}
rho_df <- bind_rows(
  glsmod16$rho_df %>% mutate(year = "2016"),
  glsmod13$rho_df %>% mutate(year = "2013"),
  glsmod10$rho_df %>% mutate(year = "2010"),
  glsmod07$rho_df %>% mutate(year = "2007"),
  glsmod04$rho_df %>% mutate(year = "2004"),
  glsmod01$rho_df %>% mutate(year = "2001")
) %>%
  mutate(
    upper95 = estimate + 1.96 * se,
    lower95 = estimate - 1.96 * se
  )

rho_df %>%
  ggplot() +
  geom_point(aes(x = year, y = estimate), size = 4) +
  geom_linerange(aes(x = year, ymin = lower95, ymax = upper95), size = 1.5) +
  geom_hline(aes(yintercept = 0), alpha = 0.5, size = 1) +
  scale_color_manual(values = c("grey50", "black")) +
  labs(x = "Election year", y = "Estimate of spatial \nautoregressive parameter") +
  lims(y = c(-0.2, 1)) +
  guides(col = FALSE) +
  coord_fixed(ratio = 1.5) +
  theme_bw() +
  theme(text = element_text(size = 14))
```

## Country-wide trend

```{r plotintercept, fig.cap = "Estimated intercept for each election, which represents the two-party preferred vote for an electorate with mean characteristics.", out.height="25%", out.extra = ''}
intercept_df <- bind_rows(
  data.frame(summary(glsmod16)$tTable)[1, ] %>% mutate(year = "2016"),
  data.frame(summary(glsmod13)$tTable)[1, ] %>% mutate(year = "2013"),
  data.frame(summary(glsmod10)$tTable)[1, ] %>% mutate(year = "2010"),
  data.frame(summary(glsmod07)$tTable)[1, ] %>% mutate(year = "2007"),
  data.frame(summary(glsmod04)$tTable)[1, ] %>% mutate(year = "2004"),
  data.frame(summary(glsmod01)$tTable)[1, ] %>% mutate(year = "2001")
) %>%
  rename(se = `Std.Error`, estimate = Value, p = `p.value`) %>%
  mutate(upper95 = estimate + 1.96 * se, lower95 = estimate - 1.96 * se)

intercept_df %>%
  ggplot() +
  geom_point(aes(x = year, y = estimate), size = 4) +
  geom_linerange(aes(x = year, ymin = lower95, ymax = upper95), size = 1.5) +
  geom_hline(aes(yintercept = 50), alpha = 0.5, size = 1) +
  labs(x = "Election year", y = "Estimate of intercept") +
  guides(col = FALSE) +
  coord_fixed(ratio = 0.2) +
  lims(y = c(45, 55)) +
  theme_bw() +
  theme(text = element_text(size = 14))
```

Since all socio-demographics were standardised to have a mean of zero and a variance of one, the intercept in each model can be interpreted as the estimated two-party preferred vote for an electorate with mean characteristics (aside from `Judaism`, `Indigenous`, `Islam` and `Buddhism`, where it assumes the mean of the log value). Figure \@ref(fig:plotintercept) shows that the baseline of party preference varied over the elections, with the biggest swing occurring in the 2007 election where the mean electorate shifted more than five percentage points in favour of the Labor party.

## Influential socio-demographics

```{r prepplot, include = FALSE, out.height="100%"}
p1 <- grid_visreg("Extractive", top = TRUE)
p2 <- grid_visreg("ManagerAdmin")
p3 <- grid_visreg("Transformative")
p4 <- grid_visreg("SocialServ")
p5 <- grid_visreg("DiffAddress")
p6 <- grid_visreg("Incomes")
p7 <- grid_visreg("OtherLanguage")
p8 <- grid_visreg("Pop_00_19")

p9 <- grid_visreg("Unemployment", top = TRUE)
p10 <- grid_visreg("BornSEEuro")
p11 <- grid_visreg("Education")
p12 <- grid_visreg("Married")
p13 <- grid_visreg("DeFacto")
p14 <- grid_visreg("OneParentHouse")
p15 <- grid_visreg("Pop_35_54")
p16 <- grid_visreg("Pop_20_34")
```

(ref:figcappartresplot1) Partial residual plots by election year for a selection of predictors. Linear model with 95% confidence bands overlaid. Most predictors had a positive relationship: the larger the value the more likely the electorate preferenced Liberal. The relationships were relatively robust over time, with the exception of `DiffAddress`, `Incomes`, `OtherLanguageHome` and `Pop_00_19`.

```{r partresplot1, fig.cap = "(ref:figcappartresplot1)", fig.height = 8.5, fig.width = 6, warning = FALSE}
(p1 / p2 / p3 / (p4 + ylab("Two-party preferred vote (%)                     ")) / p5 / p6 / p7 / p8)
```

(ref:figcappartresplot2) Partial residual plots by election year for a selection of predictors. Linear model with 95% confidence bands overlaid. Several predictors had a negative relationship: with larger values indicating the electorate more likely preferenced Labor. Most relationships were relatively stable over elections, except `Unemployment` and `Education`.


```{r partresplot2, fig.cap = "(ref:figcappartresplot2)", fig.height = 8.5,  fig.width = 6, warning = FALSE}
(p9 / p10  / p11 / (p12 + ylab("Two-party preferred vote (%)                     ")) / p13 / p14 / p15 / p16)
```

To investigate the socio-demographics that had a strong effect on the two-party preferred vote, partial residual plots are used and shown in Figures \@ref(fig:partresplot1) and \@ref(fig:partresplot2). Partial residuals, for a given variable, are the residuals from the fitted model with the estimated effect of that variable added to it. These plots show the direction, size and significance of an estimated effect, as well as any deviations from linearity. In each plot, the slope of the prediction line matches the estimated coefficient and the shaded region represents a 95% confidence band. Plots were computed using the method in @visreg. If a horizontal line can be drawn through the confidence band, then the effect is insignificant. The estimated intercept is also added to the partial residuals for interpretability. Plots for each election are faceted to compare the effects over time in Figures \@ref(fig:partresplot1) and \@ref(fig:partresplot2). Only socio-demographics that had a significant effect in at least two elections are displayed in Figures \@ref(fig:partresplot1) and \@ref(fig:partresplot2).

### Industry and type of work {-}

Electorates with higher proportions of workers in mining, gas, water, agriculture, waste and electricity (grouped as `Extractive` industries) were consistently linked with higher support for the Liberal party, with the magnitude of this effect slightly increasing over the years (see row 1 in Figure \@ref(fig:partresplot1)). This is unsurprising, as the Liberal party had maintained close ties with these traditional energy industries, and typically present policies to reduce taxation on energy production. Furthermore, electorates with more workers in construction or manufacturing industries (`Transformative`) were also more likely to support the Liberal party (see row 3 in Figure \@ref(fig:partresplot1)), from 2004 onwards.

Similarly, the proportion of workers in managerial, administrative, clerical and sales roles (`ManagerAdmin`), was also a significant predictor of two-party preference vote across all six elections, where higher proportions of people working these jobs increased Liberal support.

Of these job related variables, the most surprising effect is that associated with the proportion of workers in education, healthcare, social work, community and arts (`SocialServ`). Typically the Labor party has more generous funding schemes affecting these areas of work, so one might expect `SocialServ` to have had a negative effect on two-party preference. However, in every election this effect was found to be positive and significant.

### Income and unemployment {-}

Typically the Labor party campaigns on more progressive policies, often including tax reform that adversely affects higher income earners, and more generous social assistance programs. Perhaps it is due to these policies that higher income electorates were more likely to support the Liberal party, as the `Incomes` factor had a positive effect on Liberal preference (see row 6 in Figure \@ref(fig:partresplot1)). This effect was significant in every election aside from 2004 and 2010. `Unemployment` however, was not as influential. In 2001 and 2004, electorates with higher unemployment aligned with Labor, but over time this shifted towards support for the Liberal party, culminating in a positive (insignificant) effect in 2016.

### Age {-}

The older Australian population is often believed to be more conservative, and the left leaning political parties (including Labor) typically have a stronger appeal to younger people. This effect is indeed observed across the six elections, where populations between 20 and 34 years of age (`Pop_20_34`) aligned strongly with Labor preference (bottom row in Figure \@ref(fig:partresplot2)). Larger populations of 35 to 54 year olds (`Pop_35_54`) were also associated with Labor, but the magnitude of this effect was far smaller. Populations under 20 years of age was only significant in 2007, where `Pop_00_19` increased Liberal support.

### Education {-}

From 2007, electorates with higher education levels were associated with support for the Labor party, with this effect being significant in 2007, 2013 and 2016 and only marginally insignificant in 2010. In the elections before 2007, education had a negligible effect (see row 3 in Figure \@ref(fig:partresplot2)). Additionally, student populations (`CurrentlyStudying`) did not affect electoral party preference in any election (not shown).

### Diversity {-}

Larger migrant populations from Asia, the Middle East, South-Eastern Europe, the United Kingdom and elsewhere, were either associated with Labor support, or had no effect. Of these areas, only South-Eastern European populations significantly affected party preference, with larger populations associating with Labor in 2013 and 2016 (row 2, Figure \@ref(fig:partresplot2)). Speaking other languages (aside from English) however, appears to have had a far stronger effect, as observed through the `OtherLanguage` variable. Electorates with more diverse speech were associated with higher support for the Liberal party from 2004 onwards, with this effect being significant in 2013 and 2016 (see row 7, Figure \@ref(fig:partresplot1)). Furthermore, none of the variables relating to religious beliefs aside from Christianity had a material effect in any election (this includes the Buddhist, Muslim, Jewish, non-religious and Indigenous Australian populations). The association between Christian populations (`Christianity`) and the Liberal party steadily increased over the years, becoming positive and significant in 2016.

### Households {-}

In 2001, 2004 and 2016, higher proportions of people that recently (in the past five years) moved house (`DiffAddress`) increased electoral support for the Liberal party (see row 5 in Figure \@ref(fig:partresplot1)). This is somewhat surprising as one might expect house ownership and rental prices to be linked to two-party preference, rather than household mobility (`PropertyOwned` and `RentLoan` were not significant in any election).

Higher proportions of single parent households were associated with Labor support in all elections (albeit insignificant in 2004, see row 6 in Figure \@ref(fig:partresplot2)), whereas the electoral family and household sizes (via the `FamHouseSize` variable) did not appear to be associated with either party.

### Relationships {-}

From 2007 onwards, both marriages (`Married`) and de facto relationships (`DeFacto`) were found to be strong predictors of the two-party preferred vote in favour of the Labor party. In 2001 and 2004 neither of these variables were significant (see rows 4 and 5 in Figure \@ref(fig:partresplot2)).

## A closer look at the residuals

```{r resids, include = FALSE}
all_resids <- data.frame(
  Residuals = c(glsmod16$actual_residuals, glsmod13$actual_residuals, glsmod10$actual_residuals, glsmod07$actual_residuals, glsmod04$actual_residuals, glsmod01$actual_residuals),
  gls_residuals = c(glsmod16$residuals, glsmod13$residuals, glsmod10$residuals, glsmod07$residuals, glsmod04$residuals, glsmod01$residuals),
  bind_rows(
    glsmod16$my_data %>% left_join(tpp16 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod13$my_data %>% left_join(tpp13 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod10$my_data %>% left_join(tpp10 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod07$my_data %>% left_join(tpp07 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod04$my_data %>% left_join(tpp04 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod01$my_data %>% left_join(tpp01 %>% dplyr::select(DivisionNm, StateAb), by = "DivisionNm")
  )
)
# %>% dplyr::select(Residuals, DivisionNm, DivisionID, StateAb, year, LNP_Percent, gls_residuals)
```

### Residuals by state {-}

It is often hypothesised that states have a systematic bias towards one of the two major parties. Boxplots of residuals grouped by state (Figure \@ref(fig:resstate)) show that the data reflects this to only a limited extent. Tasmania and the Australian Capital Territory appeared to have a bias towards Labor, whereas the South Australia and the Northern Territory tended towards voting Liberal. However, there were relatively few electorates in each of these states (five, two, eleven and two respectively), so this apparent result may be due to incumbent effects rather than an actual state-specific bias.

```{r resstate, fig.cap = "Boxplot of residuals by state with jittered points. States ordered by median residual. A state-specific bias present only in the smaller states appears to have not been captured by the model.", fig.asp=0.6, out.width="70%", fig.pos = 'h', out.extra = ''}
all_resids %>%
  ggplot(aes(x = fct_reorder(StateAb, Residuals), y = Residuals)) +
  geom_hline(aes(yintercept = 0), col = "grey50") +
  geom_boxplot() +
  geom_jitter(alpha = 0.5, shape = 1) +
  guides(col = FALSE, shape = FALSE, DivisionNm = FALSE) +
  theme_bw() +
  labs(x = "State", y = "Residuals") +
  theme(text = element_text(size = 16))
```

### Residuals by party incumbency {-}

The incumbent party appeared to have a distinct advantage at the next election. The boxplots in Figure \@ref(fig:resincumbent) show that if either of the Labor or Liberal parties won the seat at the previous election, the electorate is likely to vote in their favour, over and above any socio-demographic effects---this effect has not been captured by the model.

```{r resincumbent, fig.cap = "Boxplot of residuals for incumbent and non-incumbent parties each year. An incumbent advantage is evident and has not been captured by the model.", fig.asp=0.6, out.width="70%", fig.pos = 'h', out.extra = ''}
# Load first preferences
fp16 <- eechidna::fp16 %>% 
  mutate(PartyAb = ifelse(PartyAb %in% c("LP", "NP"), "LNP", PartyAb))
fp13 <- eechidna::fp13 %>% 
  mutate(PartyAb = ifelse(PartyAb %in% c("LP", "NP"), "LNP", PartyAb))
fp10 <- eechidna::fp10 %>% 
  mutate(PartyAb = ifelse(PartyAb %in% c("LP", "NP"), "LNP", PartyAb))
fp07 <- eechidna::fp07 %>% 
  mutate(PartyAb = ifelse(PartyAb %in% c("LP", "NP"), "LNP", PartyAb))
fp04 <- eechidna::fp04 %>% 
  mutate(PartyAb = ifelse(PartyAb %in% c("LP", "NP"), "LNP", PartyAb))
fp01 <- eechidna::fp01 %>% 
  mutate(PartyAb = ifelse(PartyAb %in% c("LP", "NP"), "LNP", PartyAb))

# Incumbents
incumbent <- function(fp) {
  fp %>%
    filter(HistoricElected == "Y", PartyAb == "LNP") %>%
    dplyr::select(DivisionNm, HistoricElected)
}

# 2004-2016

incum_resids <- data.frame(
  Residuals = c(glsmod16$actual_residuals, glsmod13$actual_residuals, glsmod10$actual_residuals, glsmod07$actual_residuals, glsmod04$actual_residuals),
  bind_rows(
    glsmod16$my_data %>% dplyr::select(DivisionNm, year) %>% left_join(incumbent(fp16), by = "DivisionNm"),
    glsmod13$my_data %>% dplyr::select(DivisionNm, year) %>% left_join(incumbent(fp13), by = "DivisionNm"),
    glsmod10$my_data %>% dplyr::select(DivisionNm, year) %>% left_join(incumbent(fp10), by = "DivisionNm"),
    glsmod07$my_data %>% dplyr::select(DivisionNm, year) %>% left_join(incumbent(fp07), by = "DivisionNm"),
    glsmod04$my_data %>% dplyr::select(DivisionNm, year) %>% left_join(
      fp04 %>% filter(PartyAb %in% c("LNP", "NP", "LP")) %>%
        left_join(
          fp01 %>% rename(HistoricElected = Elected) %>% dplyr::select(UniqueID, HistoricElected, PartyAb),
          by = c("UniqueID", "PartyAb")
        ) %>% incumbent() %>% unique(), by = "DivisionNm")) %>%
    mutate(Incumbent = ifelse(is.na(HistoricElected), "N", "Y")))

ggplot(aes(x = year, y = Residuals, fill = Incumbent), data = incum_resids) +
  geom_boxplot() +
  geom_hline(aes(yintercept = 0), col = "grey50") +
  scale_fill_manual(values = c('white', 'grey'), labels = c("No", "Yes")) +
  theme_bw() +
  xlab("Year") + ylab("Residuals") +
  theme(text = element_text(size = 16))
```

## Robustness

### Multicollinearity {-}

Three robustness checks were conducted to confirm model stability. First, a model for each election was re-estimated using only the variables that were found to be significant in at least one of the six elections. The estimated coefficients of the variables in the re-estimated models all fell within their respective 95% confidence intervals from the full models. The second check involved the ten largest pairwise correlations. For each pair, a model for each election was re-estimated omitting one of the two variables. It was found that for each of these pairs, the estimated effect of the remaining variable in the reduced model was within the 95% confidence interval from the full model. The final check was a visual exploration of different variable projections using a tour [@tourr] for each election. No definitive signs of multicollinearity were observed, and as expected (given the nature of spatial data), there was some clumping of electorates for certain projections.

### Influential and outlier electorates {-}

```{r readcooksd, eval = FALSE}
read_chunk('cooksd.R')
```

```{r getcooksd, eval = FALSE}
<<GetCookDistance>>
```

```{r cooksd, eval = FALSE}
cooksd_df <- data.frame(
  Residuals = c(glsmod16$actual_residuals, glsmod13$actual_residuals, glsmod10$actual_residuals, glsmod07$actual_residuals, glsmod04$actual_residuals, glsmod01$actual_residuals),
  gls_residuals = c(glsmod16$residuals, glsmod13$residuals, glsmod10$residuals, glsmod07$residuals, glsmod04$residuals, glsmod01$residuals),
  cooksd = c(glsmod16$cooksd, glsmod13$cooksd, glsmod10$cooksd, glsmod07$cooksd, glsmod04$cooksd, glsmod01$cooksd),
  Hat = c(glsmod16$hatvalues, glsmod13$hatvalues, glsmod10$hatvalues, glsmod07$hatvalues, glsmod04$hatvalues, glsmod01$hatvalues),
  bind_rows(
    glsmod16$my_data %>% left_join(tpp16 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod13$my_data %>% left_join(tpp13 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod10$my_data %>% left_join(tpp10 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod07$my_data %>% left_join(tpp07 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod04$my_data %>% left_join(tpp04 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"),
    glsmod01$my_data %>% left_join(tpp01 %>% dplyr::select(DivisionNm, UniqueID, StateAb), by = "DivisionNm"))
)
```

```{r plothatandcooksd, eval = FALSE}
cooksd_df %>%
  ggplot(aes(x = cooksd, y = Hat)) +
  geom_point(shape = 1) +
  #geom_text(aes(label = DivisionNm), size = 3) +
  facet_wrap(~year, nrow = 2) +
  # coord_fixed(ratio = .5) +
  labs(x = "Cook's Distance", y = "Hat values") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8), axis.text.y = element_text(size = 8)) +
  theme_bw()
```


```{r plotcooksd, fig.cap = "Electorates' Cook's Distance values in each election.", out.height = "15%", eval = FALSE}
cooksd_df %>%
  ggplot(aes(x = cooksd)) +
  geom_dotplot() +
  facet_wrap(~year, nrow = 1) +
  # coord_fixed(ratio = .5) +
  labs(x = "Cook's Distance", y = "") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8), axis.text.y = element_text(size = 8)) +
  theme_bw()
```

```{r, eval = FALSE}
cooksd_df %>%
  filter(cooksd > 0.1) %>%
  dplyr::select(DivisionNm, StateAb, year, cooksd, Residuals, LNP_Percent, everything()) %>%
  View()

cooksd_df %>%
  filter(DivisionNm == "WENTWORTH") %>%
  dplyr::select(DivisionNm, StateAb, year, cooksd, Residuals, LNP_Percent, everything()) %>%
  View()
```

Based on the distribution of the Cook's distance values and the distribution of hat values, a Cook's distance greater than $0.1$ was considered to be influential, and a hat value greater than $0.5$ was considered to have high leverage. Electorates fitting these criteria were flagged and investigated to examine the characteristics driving these values. 

The electorate of Sydney (NSW) had a large Cook's distance and high leverage from 2001 to 2007, due to its diverse population (languages, birthplace and religion), high density of young adults (20 to 34 years old), high number of defacto relationships, high income, high household mobility and small amount of workers in extractive and transformative jobs. It remained a strong supporter of the Labor party and the extent of this support is underpredicted by the model, making it an outlier. Nearby in metropolitan NSW, the electorate of Wentworth was found to be an outlier in the 2013 and 2016 elections. Although historically Liberal, its two-party vote jumped by over 10 percentage points in 2010 without experiencing any notable changes in its socio-demographic makeup---implying that this may be the direct effect of its Liberal member, Malcolm Turnbull, becoming the leader of the Liberal party. In the elections since, the model underpredicts Wentworth's Liberal support.

Lingiari, an electorate making up almost all of the Northern Territory, had consistently high leverage (all years) and was an outlier in all but the 2013 election due to its large Indigenous population, low rates of property ownership and few workers in management or administrative jobs. Fowler (NSW) had a diverse population with a high proportion of migrants, many Buddhists and Muslims, as well as a high proportion of single parent households. These characteristics explain its high leverage in 2001, 2004, 2010 and 2013, and its strong Labor support made it influential in 2001, 2004 and 2010. Other electorates with large Cook's distance were Canberra (ACT) and Durack (WA) in 2013, and Solomon (NT) in 2016. 

All of the electorates examined were not unduly influential in the model and therefore no action was required.

```{r, eval = FALSE}
x <- model_df %>%
  filter(year == "2016") %>%
  dplyr::select(-c(year, DivisionNm)) %>%
  as.matrix()
myhat <- hat(x)

plot(
  glsmod16$cooksd,
  hat(
    model_df %>%
      filter(year == "2016") %>%
      dplyr::select(-c(year, DivisionNm)) %>%
      as.matrix()
  )
)
```

# Conclusion

This paper explored the effects of electoral socio-demographic characteristics on the two-party preferred vote in the 2001--2016 elections, using information from the corresponding Australian federal elections and censuses. As a census did not always occur in the same year as an election, census data for each of the 2004--2013 elections were generated by employing a method of spatio-temporal imputation. This method imputes electoral socio-demographics for the electoral boundaries in place at the time of the corresponding election---an approach that is distinctly different from previous work on modelling election outcomes, where census and election data is typically joined without addressing their temporal differences. Before estimating a model, these socio-demographic variables were standardised (to adjust for changing variable scales) and subsets of variables (representing similar information) were combined into factors, resulting in a reduced predictor set. A spatial error model was then estimated for each election, accounting for the inherent spatial structure of the data.

Across the past six elections, most of the socio-demographics driving the electoral two-party preferred vote were found to remain steady, whilst a few (typically weaker) effects varied over time. Industry and type of work were particularly influential. Energy-related and manufacturing/construction jobs, as well as administrative roles and jobs in education and social services were strongly linked with the Liberal party in all elections. Incomes had a similarly consistent effect, with higher income areas supporting Liberal. Higher levels of unemployment shifted from a weak association with Labor to a significant Liberal effect over the years, and higher education levels were associated with Labor from 2007 (although marginally insignificant in 2010). Electorates with large populations 20 to 34 years were strongly associated with Labor, whilst the 35 to 54 year old bracket also increased Labor support, but to a lesser extent. It was also found that birthplace diversity slightly favoured Labor, relationships (both marriages and de facto relationships) aligned with Labor preference from 2010 onwards, and the influence of Christian populations trended towards Liberal support whilst other religions had negligible effects. Family and household sizes had minimal influence, although electorates with more single parent households were linked with Labor support. Furthermore, the spatial effects were found to be positive in all elections and significant in 2001, 2004 and 2016, meaning that other characteristics that neighbours had in common  (outside of the variables in the model) appeared to be influential in those years.

The findings in this paper complement the existing literature by modelling temporal trends, which as far as the authors are aware, has not been done previously for Australian elections using a regression framework. It is also the first study to model any Australian election since 2010 using census information.

Additionally, a key contribution of this research is the wrangling of raw data and imputation of data sets for the 2004, 2007, 2010 and 2013 elections, which have been contributed to the \textsf{eechidna} \textsf{R} package---providing a rich, accessible data resource for any future Australian electoral analysis.

# Acknowledgements

This paper was produced using \textsf{RMarkdown} [@rmarkdown] and \textsf{knitr} [@knitr]. All corresponding code for this paper can be found in the github repository \url{github.com/jforbes14/eechidna-paper}, and the data used is available in the \textsf{eechidna} package [@eechidna]. All raw data was obtained from the Australian Electoral Commission, the Australian Bureau of Statistics and the Australian Government.

The authors would like to sincerely thank the editor and associate editor of the Australian & New Zealand Journal of Statistics and the two anonymous reviewers for providing helpful comments and suggestions on earlier drafts of this manuscript. Additionally, the authors would like to thank Anthony Ebert, Heike Hofmann, Thomas Lumley, Ben Marwick, Carson Sievert, Mingzhu Sun, Dilini Talagala, Nicholas Tierney, Nathaniel Tomasetti, Earo Wang and Fang Zhou, all of whom have contributed to the \textsf{eechidna} package.

# Software

All election and census datasets, along with electoral maps and more, are available in the \textsf{eechidna} (Exploring Election and Census Highly Informative Data Nationally for Australia) \textsf{R} package, which can be downloaded from CRAN. The \textsf{eechidna} package makes it easy to look at the data from the Australian Federal elections and censuses that occurred between 2001 and 2016. This study contributed a large revision to the \textsf{eechidna} package, which included the addition of election and census data for 2001--2010, voting outcomes for polling booths and imputed census data for election years. For more details on using \textsf{eechidna}, please see the articles (vignettes) on the github page \url{ropenscilabs.github.io/eechidna}.

# References
