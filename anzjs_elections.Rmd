---
title: "Spatial modelling of the two-party preferred vote in Australian federal elections: 2001--2016"
author: Jeremy Forbes$^*$, Dianne Cook, Rob J Hyndman
toc: false
documentclass: anzsauth
classoption: times, doublespace
fontfamily: times
bibliography: references.bib
biblio-style: anzsj
output: 
  bookdown::pdf_document2:
    fig_caption: yes
    citation_package: natbib
    keep_tex: yes
    number_sections: yes
    fig_height: 5
    fig_width: 8
    includes:
      in_header: anzjs_preamble.tex
---

# Summary{-}

We examine the relationships between electoral socio-demographic characteristics and two-party preference in the six Australian federal elections held between 2001 to 2016. Socio-demographic information is derived from the Australian Census, which occurs every five years. Since a Census is not directly available for each election, spatio-temporal imputation is employed to estimate Census data for the electorates at the time of each election. This accounts for both spatial and temporal changes in electoral characteristics between Censuses. To capture any spatial heterogeneity, a spatial error model is estimated for each election, which incorporates a spatially structured random effect vector that can be thought of as the unobserved political climate in each electorate. Over time, the impact of most socio-demographic characteristics that affect electoral two-party preference do not vary, with industry of work, incomes, household mobility and de facto relationships having strong effects in each of the six elections. Education and unemployment are amongst those that have varying effects. It is also found that between 2004 and 2013, the spatial effect was insignificant, meaning that electorates voted effectively independently. All data featured in this study has been contributed to the `eechidna` `R` package (available on CRAN).

**Keywords:** federal election, Census, Australia, spatial modelling, imputation, data science, socio-demographics, electorates, R, eechidna

# Introduction {#intro}

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  fig.pos = "h",
  fig.align = "center",
  cache = TRUE,
  message = FALSE
)
library(tidyverse)
library(eechidna)
library(forcats)
library(ggthemes)
library(knitr)
library(nlme)
library(rgeos)
library(spdep)
# remotes::install_github("thomasp85/patchwork")
library(patchwork)
#library(gridExtra)
#library(grid)
library(predictmeans)
source("functions.R")
```

```{r temporary_load_local_data, include = FALSE}
load("data/abs2004_cd.rda")
load("data/abs2007_cd.rda")
load("data/abs2010_cd.rda")
load("data/abs2013_cd.rda")
```


```{r wrangle, include = FALSE}
# Take log of indigenous, judaism, islam, buddhism
abs2016 <- eechidna::abs2016 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2013 <- abs2013_cd %>% #eechidna::abs2013 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2010 <- abs2010_cd %>% #eechidna::abs2010 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2007 <- abs2007_cd %>% #eechidna::abs2007 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2004 <- abs2004_cd %>% #eechidna::abs2004 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )
abs2001 <- eechidna::abs2001 %>%
  mutate(
    Indigenous = log(Indigenous),
    Judaism = log(Judaism),
    Islam = log(Islam),
    Buddhism = log(Buddhism)
  )

# Change abs2016 to data frame to prevent error below
abs2016 <- as.data.frame(abs2016)

# Combine and standardize
my_df <- bind_rows(
  left_join(eechidna::tpp01,
    standardise_vars(abs2001) %>%
      dplyr::select(-c(UniqueID, Area, ends_with("NS"), Population)),
    by = c("DivisionNm", "StateAb" = "State")
  ) %>% mutate(year = "2001"),
  left_join(eechidna::tpp04,
    standardise_vars(abs2004),
    by = c("DivisionNm")
  ) %>% mutate(year = "2004"),
  left_join(eechidna::tpp07,
    standardise_vars(abs2007),
    by = c("DivisionNm")
  ) %>% mutate(year = "2007"),
  left_join(eechidna::tpp10,
    standardise_vars(abs2010),
    by = c("DivisionNm")
  ) %>% mutate(year = "2010"),
  left_join(eechidna::tpp13,
    standardise_vars(abs2013),
    by = c("DivisionNm")
  ) %>% mutate(year = "2013"),
  left_join(eechidna::tpp16,
    standardise_vars(abs2016) %>%
      dplyr::select(-c(UniqueID, Area, ends_with("NS"), Population)),
    by = c("DivisionNm", "StateAb" = "State")
  ) %>% mutate(year = "2016")
) %>%
  mutate(year = factor(year), 
    Band_00_19 = Age00_04 + Age05_14 + Age15_19,
    Band_20_34 = Age20_24 + Age25_34,
    Band_35_54 = Age35_44 + Age45_54,
    Band_55plus = Age55_64 + Age65_74 + Age75_84 + Age85plus) %>% 
  select(-c(
    starts_with("Age"), MedianAge, StateAb,
    LNP_Votes, ALP_Votes, ALP_Percent, TotalVotes, Swing,
    InternetUse, InternetAccess, EnglishOnly,
    Other_NonChrist, OtherChrist, Catholic, Anglican,
    Volunteer, EmuneratedElsewhere, Population, UniqueID
  ))

# Create final df for modelling

factors_df <- my_df %>%
  mutate(
    Education = BachelorAbv + HighSchool + Professional + Finance - Laborer - Tradesperson - DipCert,
    FamHouseSize = FamilyRatio + AverageHouseholdSize + Couple_WChild_House - Couple_NoChild_House - SP_House,
    PropertyOwned = Owned + Mortgage - Renting - PublicHousing,
    RentLoanPrice = MedianRent + MedianLoanPay,
    Incomes = MedianFamilyIncome + MedianHouseholdIncome + MedianPersonalIncome,
    Unemployment = Unemployed - LFParticipation
  ) %>%
  dplyr::select(-c(
    BachelorAbv, HighSchool, Professional, Finance, Laborer, Tradesperson, DipCert, FamilyRatio,
    AverageHouseholdSize, Couple_WChild_House, Couple_NoChild_House, SP_House, Owned, Mortgage, Renting,
    PublicHousing, MedianFamilyIncome, MedianHouseholdIncome, MedianPersonalIncome, MedianRent,
    MedianLoanPay, Unemployed, LFParticipation
  ))

# Now standardize factors

small_df <- bind_rows(
  factors_df %>% filter(year == "2001") %>% standardise_vars(),
  factors_df %>% filter(year == "2004") %>% standardise_vars(),
  factors_df %>% filter(year == "2007") %>% standardise_vars(),
  factors_df %>% filter(year == "2010") %>% standardise_vars(),
  factors_df %>% filter(year == "2013") %>% standardise_vars(),
  factors_df %>% filter(year == "2016") %>% standardise_vars()
)

# Order electorates in alphabetical order to match spatial matrix
model_df <- small_df %>%
  arrange(year, DivisionNm) %>%
  dplyr::select(order(colnames(.))) %>%
  rename(
    ManagerAdmin = ManagerAdminClericalSales,
    OtherLanguage = OtherLanguageHome,
    BornSEEuro = Born_SE_Europe,
    BornAsia = Born_Asia,
    OneParentHouse = OneParent_House,
    Pop_00_19 = Band_00_19,
    Pop_20_34 = Band_20_34,
    Pop_35_54 = Band_35_54
  ) %>% 
  select(-Band_55plus)
```

```{r spatialweights, eval = FALSE}
# Get spatial weights
# This is not run, as weights are pulled from github, but this can be run to get them from scratch.
sF_16 <- sF_download(2016)
sF_13 <- sF_download(2013)
sF_10 <- sF_download(2010)
sF_07 <- sF_download(2007)
sF_04 <- sF_download(2004)
sF_01 <- sF_download(2001)

sp_weights_16 <- sp_weights_matrix(sF_16)
sp_weights_13 <- sp_weights_matrix(sF_13)
sp_weights_10 <- sp_weights_matrix(sF_10)
sp_weights_07 <- sp_weights_matrix(sF_07)
sp_weights_04 <- sp_weights_matrix(sF_04)
sp_weights_01 <- sp_weights_matrix(sF_01)
```

```{r FGLS, include = FALSE}
# Instead of running spatial weights, load from github
load("data/sp_weights_01.rda")
load("data/sp_weights_04.rda")
load("data/sp_weights_07.rda")
load("data/sp_weights_10.rda")
load("data/sp_weights_13.rda")
load("data/sp_weights_16.rda")

## Run full models for each year
full_formula <- "LNP_Percent ~ ."

# 2016
glsmod16 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2016"),
  sp_weights = sp_weights_16
)

# 2013
glsmod13 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2013"),
  sp_weights = sp_weights_13
)

# 2010
glsmod10 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2010"),
  sp_weights = sp_weights_10
)

# 2007
glsmod07 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2007"),
  sp_weights = sp_weights_07
)

# 2004
glsmod04 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2004"),
  sp_weights = sp_weights_04
)

# 2001
glsmod01 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2001"),
  sp_weights = sp_weights_01
)

## Visualise coefficients and significance

coef_df <- bind_rows(
  data.frame(
    variable = glsmod16$coefficients %>% names(),
    estimate = glsmod16$coefficients %>% unname(),
    se = summary(glsmod16)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod16)$tTable[, "p-value"] %>% unname(),
    year = 2016),
  data.frame(
    variable = glsmod13$coefficients %>% names(),
    estimate = glsmod13$coefficients %>% unname(),
    se = summary(glsmod13)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod13)$tTable[, "p-value"] %>% unname(),
    year = 2013),
  data.frame(
    variable = glsmod10$coefficients %>% names(),
    estimate = glsmod10$coefficients %>% unname(),
    se = summary(glsmod10)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod10)$tTable[, "p-value"] %>% unname(),
    year = 2010),
  data.frame(
    variable = glsmod07$coefficients %>% names(),
    estimate = glsmod07$coefficients %>% unname(),
    se = summary(glsmod07)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod07)$tTable[, "p-value"] %>% unname(),
    year = 2007),
  data.frame(
    variable = glsmod04$coefficients %>% names(),
    estimate = glsmod04$coefficients %>% unname(),
    se = summary(glsmod04)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod04)$tTable[, "p-value"] %>% unname(),
    year = 2004),
  data.frame(
    variable = glsmod01$coefficients %>% names(),
    estimate = glsmod01$coefficients %>% unname(),
    se = summary(glsmod01)$tTable[, "Std.Error"] %>% unname(),
    p = summary(glsmod01)$tTable[, "p-value"] %>% unname(),
    year = 2001)
)
```

Australia has changed in many ways over the last two decades. Rising house prices, country-wide improvements in education, an ageing population, and a decline in religious affiliation, are just a few facets of the country's evolving socio-demographic characteristics. At the same time, political power has moved back and forth between the two major parties. In the 2007 and 2010 federal elections, the Australian Labor Party (Labor) was victorious, whereas the 2001, 2004, 2013 and 2016 elections were won by the Liberal National coalition (Liberal). The two-party preferred vote, a measure of support between these two parties, fluctuated between 47.3% and 53.5% (in favour of the Liberal party) over this period. This study explores how electoral socio-demographic characteristics relate to two-party preference, and whether their effects have changed over time.

Data on electoral socio-demographics are derived from the Australian Census, and vote counts are obtained from Australian federal elections. Joining these two data sources is problematic as there is an inherent asynchronicity in the two types of events. A Census is conducted by the Australian Bureau of Statistics (ABS) every five years, whereas federal elections, conducted by the Australian Electoral Commission (AEC), usually occur every three years or so. The first problem addressed is that of constructing appropriate Census data for the 2004, 2007, 2010 and 2013 elections --- election years in which a Census does not occur. The predominant approach in previous studies was to join voting outcomes to the nearest Census, without accounting for any temporal differences [see @DavisStimson98;@Stimson06;@Liao09;@Stimson09]. Furthermore, electoral boundaries change regularly, so spatial discrepancies also arise when matching with electoral data. To obtain appropriate "Census-like" data for these four elections, electoral socio-demographics are constructed using a spatio-temporal imputation that combines areal interpolation [@Goodchild1993] and linear time-interpolation. Collecting and wrangling the raw data, along with the imputation process, are detailed in Section \@ref(data). All data and associated documentation relating to this procedure are available in the `eechidna` `R` package [@eechidna], providing a resource for future analysis.

Previous work on modelling Australian federal elections has found that aggregate socio-demographics are relatively good predictors of voting outcomes. @Forrest01 used multiple regression to model the Liberal and Labor primary vote for polling booths in the Farrer electorate in 1998 as a function of Census variables from 1996. @Stimson06, @Stimson09 and @Stimson12 used principal component analysis of polling booths in the 2001, 2004 and 2007 elections respectively, also finding that socio-demographic characteristics of polling booths are linked to their two-party preferred vote. In contrast, @Stimson09 models the polling booth swing vote (change in the two-party preferred vote) in the 2007 election, finding that little of the swing vote can be explained by Census data.

Instead of analyzing a single election in isolation, this paper employs a consistent model framework across six elections so that temporal changes in the effects of socio-demographics can be observed. Each federal election is modelled with a cross-sectional dataset. <!--The use of a regression framework to examine these socio-political relationships over time is seemingly absent from previous Australian studies. It also appears that no study has attempted any type of statistical analysis of socio-demographics in conjunction with voter behaviour in Australia since 2007, making this paper distinctly different from previous work.-->
The cross-sectional dataset for each election used here consists of the two-party preferred vote (as the response variable), and a set of common socio-demographic variables (as the explanatory variables) that characterize each electorate. To prepare these datasets, socio-demographic variables are first standardized, and then a principal component analysis is used to group variables into "factors". To account for the inherent spatial structure of the data, a spatial error model is then estimated for each election. 

The paper is organised as follows. Section \@ref(data) describes the data collection, joining and cleaning. These pre-processing steps and model details are discussed in Section \@ref(modelling). Section \@ref(results) describes the inference conducted to determine signficance of effects and how these change over time. Section \@ref(conclusion) summarises the work. Two supplementary sections document the contributions of others to this work and the software.

# Data collection, wrangling and imputation {#data}

## Collecting the data

The voting outcome of interest is the electoral two-party preferred vote, which is provided by the Australian Electoral Commission (AEC) for the 2001, 2004, 2007, 2010, 2013 and 2016 elections via the AEC Tally Room. The AEC divides Australia into 150 regions, called electorates, with each corresponding to a single seat in the House of Representatives. Voting is compulsory in Australia, and each voter assigns a numbered preference to each available candidate in their electorate. The two-party preferred vote is determined by a tally of these preferences where, by convention, only the ranks of the Labor and Liberal candidates are considered. This is recorded as a percentage preference in favour of the Liberal party.

Socio-demographic variables were derived from the Australian Census of Population and Housing (Census), which is a survey of every household in Australia, recording information such as age, gender, ethnicity, education level and income. There have been four Censuses so far in the 21st century, conducted in 2001, 2006, 2011 and 2016. The Australian Bureau of Statistics (ABS) conducts the Census and publishes aggregated information. The ABS uses electoral boundaries as defined by the AEC at the time of each Census, which may not match those in place at the subsequent and previous elections. From the available Census information aggregated at the electorate level, 50 socio-demographic variables were defined for each of the electorates to be used in the analysis.

Raw data was sourced online from the AEC and ABS websites in `.csv` and `.xlsx` files. The formats of these files differ over the years, making extracting the appropriate information a big task. The functions available in the `dplyr` [@dplyr] and `readxl` [@readxl] `R` packages are particularly useful, as they provide fast consistent tools for data manipulation and functions to import `.xlsx` files (respectively). The 2001 and 2006 Census data are published in a format where the information for each electorate is held in a separate document making it difficult to use the `dplyr` tools. Instead, cells have to be selected from each individual file to construct the desired variables. All scripts required for the data wrangling process can be found in the github repository for the `eechidna` `R` package [@eechidna], along with the raw data. The `eechidna` package makes this study entirely reproducible and provides a resource to help wrangle data for future Censuses and elections, when they become available.

## Joining Census and election data

### Differences between Census and election data {-} 

Between 2001 and 2016 there were six elections and four Censuses (see Figure \@ref(fig:timeline)). Electoral boundaries are redistributed regularly by the AEC, meaning that only in the years where both a Census and election occur are all boundaries likely to match --- the case for the 2001 and 2016 elections. Therefore, for the four elections between 2004 and 2013, both temporal and spatial differences in electorates need to be accounted for when joining the electoral two-party preferred vote with Census data. For these elections a spatio-temporal imputation method was employed to obtain electoral socio-demographics. This method uses Census information from both before and after the election of interest.

```{r timeline, echo = FALSE, fig.cap="Timeline of Australian elections and Censuses. They do not always occur in the same year.", out.width = "90%", fig.align="center"}
timeline <- data.frame(year = c(2001:2016)) %>%
  mutate(
    Election = ifelse(year %in% c(2001, 2004, 2007, 2010, 2013, 2016), 1, 0),
    Census = ifelse(year %in% c(2001, 2006, 2011, 2016), 1.4, 0)
  ) %>%
  gather(c(Election, Census), key = event, value = measure) %>%
  filter(measure != 0) %>%
  mutate(year_vis = ifelse(event == "Census", year + 0.1, year))


ggplot(timeline, aes(x = year_vis, y = measure)) +
  geom_point(aes(color = as.factor(event), shape = as.factor(event)), size = 4) +
  labs(color = "Event", shape = "Event", x = "Year") +
  geom_hline(yintercept = 0, size = 1, color = "grey", show.legend = FALSE) +
  geom_segment(x = 2001, xend = 2001, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2004, xend = 2004, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2007, xend = 2007, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2010, xend = 2010, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2013, xend = 2013, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2016, xend = 2016, y = 1, yend = 0, color = "#00BFC4") +
  geom_segment(x = 2001.1, xend = 2001.1, y = 1.4, yend = 0, color = "#F8766D") +
  geom_segment(x = 2006.1, xend = 2006.1, y = 1.4, yend = 0, color = "#F8766D") +
  geom_segment(x = 2011.1, xend = 2011.1, y = 1.4, yend = 0, color = "#F8766D") +
  geom_segment(x = 2016.1, xend = 2016.1, y = 1.4, yend = 0, color = "#F8766D") +
  theme(
    text = element_text(size = 10),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    plot.background = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_blank()
  ) +
  scale_x_discrete(limits = c(2001:2016)) +
  coord_fixed(ratio = 2)
```

### Spatio-temporal imputation {-}

For each election, neighbouring Census information has to be combined in some way so that it represents the boundaries in place at the time of the election. This is done by taking the electoral boundaries and imputing the corresponding socio-demographic characteristics for each of neighbouring Censuses, thereby addressing the spatial aspect. Next, to deal with the temporal component, characteristics at the time of the election are constructed using linear interpolation between the spatially imputed neighbouring Census variables.

The finest level of disaggregation available for Census data is the region classification called Statistical Area 1 (SA1). In 2016, Australia was divded into over 55,000 SA1s. Consider each of these SA1 regions as a source zone, $s = 1,\dots,S$, for which socio-demographic information is available. For simplicity, let each source zone be wholly summarised by its centroid. A set of target zones, $t = 1,\dots,T$, are defined as regions for which information is to be imputed - these are the electoral boundaries for a particular election. This is described in the context of a single election, and a single neighbouring Census. Take the example of the Melbourne Ports electorate from the 2013 federal election, illustrated in Figure \@ref(fig:melbports13). The purple region in this figure represents the target zone and the source zones are the centroid locations from the 2016 Census SA1 areas. 

```{r melbports13, fig.cap = "The electoral boundaries for Melbourne Ports (shown in purple) and surrounding electorates, with centroids for Statistical Area 1 regions from the 2016 Census overlaid. The centroids falling within the purple region are attributed to Melbourne Ports.", out.height="28%"}
# Get Vic shape
load("data/vic_map.rda")
load("data/MP_sa1_dots_2011.rda")

p1 <- ggplot(data = vic_map) +
  geom_polygon(aes(x = long, y = lat, group = group, fill = Elect_div == "Melbourne Ports"),
    colour = "black", alpha = 0.4
  ) +
  scale_fill_manual(
    name = "Electoral Boundaries",
    values = c("white", "purple"),
    labels = c("Other Electorates", "Melbourne Ports (VIC)")
  ) +
  theme_map() +
  coord_equal(xlim = c(144.88, 145.07), ylim = c(-37.92, -37.78))

p1 + geom_point(aes(x = long_c, y = lat_c, shape = shape), data = MP_sa1_dots_2011 %>% mutate(shape = "1"), colour = "grey25", size = 1.3) + scale_shape_manual(name = "Statistical Area 1", values = 3, labels = "Centroids")
```

Furthermore, let $I_{s,t}$ be an indicator variable, for which $I_{s,t} = 1$ if the centroid of source zone $s$ falls within target zone $t$, and $0$ otherwise. Additionally, let the population of the source zone $s$ be $U_s$ and the population of target zone $t$ be $P_{t}$. 

In order to calculate socio-demographic information for each of the target zones, a weighted average of source zones is taken using their populations as weights. Denote a given Census variable for the target zone by $C_t$, and the same Census variable for the source zone as $D_s$. Then, estimate $C_t$ using
$$
  \hat{C}_t = \frac{\sum_{s=1}^{S}{I_{s,t}*D_s*U_s}}%
  {\sum_{s=1}^{S}{I_{s,t}*U_s}},
  \quad\text{for each $t=1,\dots,T$}.
$$

This concludes the spatial imputation of the socio-demographic characteristics for one target zone (a single electoral boundary), at the time of only one of the neighbouring Censuses. This process is repeated for all of the target zones, and then for the other neighbouring Census.

\enlargethispage*{0.5cm}

To account for temporal changes, linear interpolation is used between Census years to get the final estimate of a Census variable for the target zone in the election year. Let $y_1$ be the year of the Census preceding an election, let $y_2$ be the year of the election, and $y_3$ be the year of the Census that follows. Add this year subscript to the Census variable estimate $\hat{C}_t$, resulting in $\hat{C}_{t,y}$. Linear interpolating between these Census years results an imputed value for the election year, given by
$$
  \hat{C}_{t,y_2} = \frac{y_3-y_2}{y_3-y_1} * \hat{C}_{t,y_1} +
    \frac{y_2-y_1}{y_3-y_1} * \hat{C}_{t,y_3}.
$$
Implicitly this assumes that population characteristics change in a linear manner over time.

Continuing with the example of Melbourne Ports in the 2013 election, the estimate for a given Census variable in 2016, $\hat{C}_{MelbPorts, 2016}$ would be obtained by computing the weighted average of this variable amongst the SA1s within the purple region shown in Figure \@ref(fig:melbports13). This would be repeated with the 2011 Census SA1s to obtain $\hat{C}_{MelbPorts, 2011}$, from which the final estimate is given by
$$
  \hat{C}_{\text{MelbPorts},2013}
    = \frac{3}{5} \hat{C}_{\text{MelbPorts},2011} + \frac{2}{5} \hat{C}_{\text{MelbPorts},2016}.
$$
This is done for each of the socio-demographic variables, and is repeated for each of the 149 remaining target zones corresponding with 2013 electorates.

# Modelling {#modelling}

Following this process, electoral socio-demographic variables are available for each of the six elections and can be joined with their corresponding two-party preferred votes. Before choosing an appropriate model, two issues with the socio-demographic variables need to be addressed. First, variable scales change over the years, making it important to standardize variables. Second, many variables represent similar information and where appropriate, should be grouped together. To determine which variables should be grouped, principal component analysis (PCA) is used. The intuition here is that PCA will identify which variables covary, from which intuitive groupings of variables can be chosen to combine into a single variable. After these steps, a model specification is chosen.

## Standardizing variables

Many of the socio-demographic variables have changing scales over the years. For example, inflation-adjusted median rental prices increased across almost all electorates, with median rent of 225 dollars per week placing an electorate in the 90th percentile in 2001, but only the 45th percentile in 2016. In order for socio-demographic effects to be comparable across years, all explanatory variables are standardized to have mean zero and variance one within each election year. By standardizing, each variable is reported as a relative measure compared to all other electorates in the same year.

## Creating factors

There are only $N = 150$ observations (electorates) in each election and $p = 50$ socio-demographic variables in each cross-section, with many variables represent similar information about an electorate. Any model that uses all variables would face problems with multi-collinearity and over-fitting, which would likely lead to erroneous conclusions regarding variable significance. To address this, variables that represent similar information are combined into a single variable, which will be referred to as a "factor".

A factor is created from a group of variables if there is an intuitive reason as to why these variables should represent similar information and if there is evidence to suggest that they covary. For example, a potential group would be variables relating to electoral incomes --- median family, household and personal incomes. To determine which variables covary, principal component analysis is used on a combined dataset of socio-demographic variables from all six elections[^2]. The only variables exempted from the principal component analysis are the four variables representing age brackets (the proportion of the population aged 0-19 years old, 20-34 years old, 45-54 years old and 55 years plus), which are to be included in the model as separate variables by construction.

[^2]: It is appropriate to compute principal components on a combined dataset of all six elections because when computed separately for each election, scree plots level off after four components and the loadings of the first four components are similar across the elections.

Only the first four principal components from the combined dataset are considered, as the scree plot corresponding to the combined dataset levels off after the fourth component. Variables that have a large loading in a particular component are deemed to covary, with a loading with magnitude greater than 0.15 being considered large. Six factors are created using this criteria. These are:
`Incomes` (median personal income, median household income, median family income);
`Unemployment` (unemployment rate, labor force participation rate);
`PropertyOwned` (proportion of dwellings that are owned, proportion of dwellings that are mortgages, proportion of dwellings that are rented, proportion of dwellings that classified as government housing);
`RentLoanPrice` (median rental payment amount, median loan repayment amount);
`FamHouseSize` (average household size, ratio of people to families, incidence of single person households, incidence of households containing a couple with kids, incidence of households containing a couple without kids); and
`Education` (high school completions, university qualifications, jobs requiring higher levels of education, vocational course completions, jobs that do not require higher education levels).
For each of these groupings, a factor is created by taking a weighted sum of the variables. The weightings are allocated on the basis of whether the variable had a positive or negative loading in the principal component from which the grouping was identified. Variables with a positive loading are allocated a weight of $+1$ and those with negative loadings are allocated a weight of $-1$. After computing these weighted sums, the factor is standardized to have mean zero and variance one, within each election.

There are $p=32$ variables in the resultant predictor set, with all of these used in the regression for each election.

## Regression incorporating spatially dependent errors

An identical model specification is used for each of the six elections, with each election modelled separately. This allows the socio-demographic effects to be estimated separately for each election year, facilitating analysis of temporal changes in variable effects. This approach is preferable to using a single longitudinal model because it avoids imposing any time-varying restrictions on the effect of a variable. To gain any advantage over modelling each election as a separate cross-section, a pooled cross-sectional model would have to force the effects at least some variables to be invariant over time. This would not allow for conclusions to be drawn about how the effects of these variables change over time. Furthermore, the panel approach is avoided because of how frequently electoral boundaries change, noting that electorates with the same name across elections are not guaranteed to represent the same geographical region. Therefore any fixed or random effects models would be difficult to estimate without implementing consistent boundaries, which would require further imputation (of voting information).

For each cross-section, let the response $\bm{y}$ be the vector two-party preferred vote in favour of the Liberal party; for example,  $y_i = 70$ represents a 70% preference for Liberal, 30% for Labor, in electorate $i$. Although $y_i$ lies in the interval $(0,100)$, observed values are never close to 0 or 100 (minimum $24.05 \%$ and maximum $74.90 \%$), so there is no need to formally impose the constraint of $y_i \in [0,100]$. Furthermore, the responses are found to be spatially correlated in each election (Moran's I test, $p \le 7\cdot10^{-15}$). This is not surprising as electorates are aggregate spatial units, and hence the spatial structure of the data must be modelled appropriately.

The spatial error model [@Anselin88] is chosen because it captures spatial heterogeneity by incorporating a spatially structured random effect vector [@LeSage2009]. In this context, the random effect can be thought of as capturing the unobserved political climate in each electorate, where this climate is correlated with the climate in neighbouring electorates, under the assumption that the climate is independent of electoral socio-demographics.

```{r printmodels, warning=FALSE, message=FALSE, include=FALSE}
# Add rho and GLS residual standard error
regtable <- stargazer::stargazer(
  glsmod01, glsmod04, glsmod07, glsmod10, glsmod13, glsmod16,
  header = FALSE,
  column.sep.width = "2pt",
  no.space=TRUE,
  model.numbers=FALSE,
  keep.stat = c("n","ser"),
  dep.var.caption="",
  dep.var.labels="\\vspace{-0.4cm}",
  title = "Estimated spatial error model parameters (standard errors) for each of the six election years.\\vspace*{-0.4cm}",
  #dep.var.labels = "Two-party preferred vote in favor of the Liberal party",
  font.size = "scriptsize",
  digits = 2,
  column.labels = c("2001", "2004", "2007", "2010", "2013", "2016"),
  label="tab:printmodels"
  #notes = c("Estimated coefficients for variable named in column one shown for", "election year indicated by column heading, with estimated standard", "deviation for each coefficient shown below in parenthesis. Overall", "summary measures for each regression equation are provided in the", "bottom panel."),
  #notes.align = "l"
)
# Add correlations
getrho <- function(x, element) {x$rho_df[[element]]}
rho <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getrho, element="estimate")
rhop <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getrho, element="p")
rhose <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getrho, element="se")
rholine1 <- paste("$\\rho$",
            paste(" & ",
                  sprintf("%3.2f",rho),
                  ifelse(rhop < 0.01, "$^{***}$",
                  ifelse(rhop < 0.05, "$^{**}$",
                  ifelse(rhop < 0.10, "$^{*}$",""))),
              sep="", collapse=""),
            "\\\\", sep="", collapse="")
rholine2 <- paste("",
            paste(" & (",
                  sprintf("%3.2f",rhose), ")",
              sep="", collapse=""),
            "\\\\", sep="", collapse="")
regtable <- c(regtable[1:11], rholine1, rholine2, regtable[12:length(regtable)])
# Add residual standard error (GLS)
getsigma <- function(x, element) {x$sigma}
sigma <- map_dbl(list(glsmod01,glsmod04,glsmod07,glsmod10,glsmod13,glsmod16),
           getsigma)
sigmaline <- paste("Residual Standard Error (GLS)",
             paste(" & ",
                   sprintf("%4.2f", sigma),
                   sep="", collapse=""),
             "\\\\", sep="", collapse="")
regtable <- c(regtable[1:77],sigmaline, regtable[78:length(regtable)])
# Squeeze some more space
regtable[2] <- "\\begin{table}[!htbp]\\vspace*{-0.4cm}\\centering "     
# Allow alignment on decimal point
regtable[6] <- "\\begin{tabular}{@{\\extracolsep{1pt}}lrrrrrr}" 
regtable[12:75] <- gsub(")","\\\\rlap{)}",regtable[12:75])
regtable[12:75] <- gsub("$^{*}$","\\rlap{$^{*}$}", regtable[12:75], fixed=TRUE)
regtable[12:75] <- gsub("$^{**}$","\\rlap{$^{**}$}", regtable[12:75], fixed=TRUE)
regtable[12:75] <- gsub("$^{***}$","\\rlap{$^{***}$}", regtable[12:75], fixed=TRUE)
# Column spacing
regtable[5] <- "\\scriptsize\\tabcolsep=0.35cm"
# Remove "Note"
regtable[81] <- "& \\multicolumn{6}{r}{$^{*}$p$<$0.1; $^{**}$p$<$0.05; $^{***}$p$<$0.01} \\\\"
```

```{r printmodels2, results='asis', dependson='printmodels'}
cat(regtable)
```

Spatial weights are calculated in accordance with the assumption that an electorate is equally correlated with any electorate that shares a part of its boundary. Let $\rho$ be the spatial autoregressive coefficient, $\bm{v}$ be a spherical error term, $\bm{W}$ be a matrix of spatial weights (containing information about the neighbouring regions), $\bm{X}$ be a matrix of socio-demographic covariates, $\bm{\beta}$ be a vector of regression coefficients and $\bm{a}$ be a spatially structured random effect vector.
$$
  \bm{y} = \bm{X} \bm{\beta} + \bm{a},
$$
and
$$
  \bm{a} = \rho \bm{W} \bm{a} + \bm{v},
$$
where $\bm{v} \sim N(\bm{0}, \sigma^2 \bm{I_n})$, and hence
$$
  \bm{y} = \bm{X} \bm{\beta} + (\bm{I}_n-\rho \bm{W})^{-1}\bm{v}.
$$
Estimation of the above spatial error model is undertaken using feasible generalized least squares.

Table \@ref(tab:printmodels) details the estimated model coefficients and their estimated standard errors, for each of the six elections. An interpretation of these estimated values is provided in the next section.

# Results

## Spatial autoregressive parameter

The spatial autoregressive coefficient $\rho$ is positive and significant in only the 2001 and 2016 elections (Figure \@ref(fig:rhovis)), meaning that in these elections, the political climate of an electorate appears to be affected by the attitudes of its neighbours. Conversely, in the other four elections, the spatial effect weakens to become insignificant. In these years, it appears that the spatial component does not explain anything not already explained by the electoral socio-demographics, meaning electorates effectively voted independently.

```{r rhovis, fig.cap="Estimates of the spatial autoregressive parameter for each of the six elections, reported with their individual 95\\% confidence intervals. Only in 2001 and 2016 is there a significant spatial component.", out.height='20%', out.extra = ''}
rho_df <- bind_rows(
  glsmod16$rho_df %>% mutate(year = "2016"),
  glsmod13$rho_df %>% mutate(year = "2013"),
  glsmod10$rho_df %>% mutate(year = "2010"),
  glsmod07$rho_df %>% mutate(year = "2007"),
  glsmod04$rho_df %>% mutate(year = "2004"),
  glsmod01$rho_df %>% mutate(year = "2001")
) %>%
  mutate(
    upper95 = estimate + 1.96 * se,
    lower95 = estimate - 1.96 * se
  )

rho_df %>%
  ggplot() +
  geom_point(aes(x = year, y = estimate), size = 3) +
  geom_linerange(aes(x = year, ymin = lower95, ymax = upper95), size = 1.2) +
  geom_hline(aes(yintercept = 0), alpha = 0.5, size = 1) +
  scale_color_manual(values = c("grey50", "black")) +
  labs(x = "Election year", y = "Estimate of spatial autoregressive parameter") +
  lims(y = c(-1, 1)) +
  guides(col = FALSE) +
  coord_fixed(ratio = 1) +
  theme_bw()
```

## Country-wide trend

```{r plotintercept, fig.cap = "Estimated intercept for each election, which represents the two-party preferred vote for an electorate with mean characteristics.", out.height="20%", out.extra = ''}
intercept_df <- bind_rows(
  data.frame(summary(glsmod16)$tTable)[1, ] %>% mutate(year = "2016"),
  data.frame(summary(glsmod13)$tTable)[1, ] %>% mutate(year = "2013"),
  data.frame(summary(glsmod10)$tTable)[1, ] %>% mutate(year = "2010"),
  data.frame(summary(glsmod07)$tTable)[1, ] %>% mutate(year = "2007"),
  data.frame(summary(glsmod04)$tTable)[1, ] %>% mutate(year = "2004"),
  data.frame(summary(glsmod01)$tTable)[1, ] %>% mutate(year = "2001")
) %>%
  rename(se = `Std.Error`, estimate = Value, p = `p.value`) %>%
  mutate(upper95 = estimate + 1.96 * se, lower95 = estimate - 1.96 * se)

intercept_df %>%
  ggplot() +
  geom_point(aes(x = year, y = estimate), size = 3) +
  geom_linerange(aes(x = year, ymin = lower95, ymax = upper95), size = 1.2) +
  geom_hline(aes(yintercept = 50), alpha = 0.5, size = 1) +
  labs(x = "Election year", y = "Estimate of intercept") +
  guides(col = FALSE) +
  coord_fixed(ratio = 0.2) +
  lims(y = c(45, 55)) +
  theme_bw()
```

Since all socio-demographics have been standardized to have a mean of zero and a variance of one, the intercept in each model can be interpreted as the estimated two-party preferred vote for an electorate with mean characteristics[^3]. Figure \@ref(fig:plotintercept) shows that the baseline of party preference has varied over the elections, with the biggest swing occurring in the 2007 election where the mean electorate shifted more than five percentage points in favour of the Labor party.

[^3]: Mean of all variables aside from Judaism, Indigenous, Islam and Buddhism, where it assumes the mean of the log value.

## Influential socio-demographics

```{r prepplot, include = FALSE}
p1 <- grid_visreg("Extractive", top = TRUE)
p2 <- grid_visreg("DiffAddress")
p3 <- grid_visreg("ManagerAdmin")
p4 <- grid_visreg("Transformative")
p5 <- grid_visreg("Incomes")
p6 <- grid_visreg("Unemployment")

p7 <- grid_visreg("MedianAge", top = TRUE)
p8 <- grid_visreg("Judaism")
p9 <- grid_visreg("OtherLanguage")
temp <- grid_visreg("OtherLanguage")
p10 <- grid_visreg("BornAsia")
p11 <- grid_visreg("Education")
p12 <- grid_visreg("BornSEEuro")
p13 <- grid_visreg("DeFacto")
```


```{r partresplot1, fig.cap = "Partial residual plots by election year for a selection of predictors. Linear model with 95\\% confidence bands overlaid. Most predictors have a positive relationship: the larger the value the more likely the electorate preferences the Coalition. The relationship is relatively robust over time, with the exception of Unemployment.", fig.height = 8.5, fig.width = 6, warning = FALSE, fig.pos = 'h'}
(p1 / p2 / (p3 + ylab("Two-party preferred vote (%)                     ")) / p4 / p5 / p6)
```

```{r partresplot2, fig.cap = "Partial residual plots by election year for a selection of predictors. Linear model with 95\\% confidence bands overlaid. Several predictors have a negative relationship: with larger values indicating the electorate more likely preferences Labor. Most relationships are relatively stable over elections, except OtherLanguage and Education.", fig.height = 8.5,  fig.width = 6, warning = FALSE, fig.pos = 'h'}
(p7 / p8 / (p9 + ylab("Two-party preferred vote (%)                     ")) / p10 / p11 / p12 / p13)
```

To investigate the socio-demographics that have a strong effect on the two-party preferred vote, partial residual plots are used and shown in Figures \@ref(fig:partresplot1) and \@ref(fig:partresplot2). Partial residuals for a variable are the residuals from the fitted model with the estimated effect of that variable added to it. These plots show the direction, size and significance of an estimated effect, as well as any deviations from linearity. In each plot, the slope of the prediction line matches the estimated coefficient and the shaded region represents a 95% confidence band. Plots are computed using the method in @visreg. If a horizontal line can be drawn through the confidence band, then the effect is insignificant. The estimated intercept is also added to the partial residuals for interpretability. Plots for each election are faceted to compare the effects over time in Figures \@ref(fig:partresplot1) and \@ref(fig:partresplot2). Only socio-demographics that have a significant effect in at least one election are displayed in Figures \@ref(fig:partresplot1) and \@ref(fig:partresplot2).

It is important here to note the ecological fallacy: insights are being drawn at the electorate level, and cannot be inferred for another disaggregate level (e.g. individual voters).

### Income and unemployment {-}

Typically the Labor party campaigns on more progressive policies, which often include tax reform that adversely affects higher income earners, and more generous social assistance programs. Perhaps it is due to these policies that higher income electorates appear more likely to support the Liberal party, as the `Incomes` factor has a positive effect on Liberal preference (see row 1 in Figure \@ref(fig:partresplot1)). This effect is significant in every election aside from 2004, where it is only marginally insignificant ($p = 0.0613$). Unemployment however, is not as influential. In 2001 and 2004, electorates with higher unemployment align with Labor, but over time this shifts towards support for the Liberal party, culminating in a significantly positive effect in 2016.

### Industry and type of work {-}

Electorates with higher proportions of workers in mining, gas, water, agriculture, waste and electricity (grouped as `Extractive` industries) are consistently linked with higher support for the Liberal party, with the magnitude of this effect slightly increasing over the years (see row 3 in Figure \@ref(fig:partresplot1)). This is unsurprising, as the Liberal party has close ties with these traditional energy industries, and typically present policies to reduce taxation on energy production. Furthermore, electorates with more workers in construction or manufacturing industries (`Transformative`) are also more likely to support the Liberal party (see row 4 in Figure \@ref(fig:partresplot1)).

Similarly, the proportion of workers in managerial, administrative, clerical and sales roles (`ManagerAdmin`) is also a significant predictor of two-party preference vote across all six elections, with a higher proportion of people working these jobs increasing Liberal support. The magnitude of this effect also seems to increase over the years.

### Household mobility {-}

In each of the six elections, electorates with a higher proportion of people that have recently (in the past five years) moved house (`DiffAddress`) are more likely to support the Liberal party, although this effect was marginally insignificant in 2013 (see row 6 in Figure \@ref(fig:partresplot1). Having controlled for characteristics of house ownership and rental prices (via the factors `PropertyOwned` and `RentLoan` respectively), this effect is somewhat surprising.

### Relationships {-}

De facto relationships, but not marriages, are found to be an important (and significant) predictor of the two-party preferred vote in all six elections, with more de facto relationships associated with higher support for the Labor party. The proportion of individuals who are married however, is insignificant (not shown).

### Age {-}

Regions comprising more older people are often believed to be more conservative, and indeed it found that electorates with a higher median age are more likely to support the Liberal party --- although this effect is significant only in 2007 and 2010 (see row 2 in Figure \@ref(fig:partresplot2)).

### Education {-}

Since 2007, electorates with higher education levels are associated with supporting the Labor party, although this effect is significant only in 2016. Before 2007, education has an almost zero effect (see row 3 in Figure \@ref(fig:partresplot1)).

### Diversity {-}

Larger migrant populations from Asia, the Middle East, South-Eastern Europe, the United Kingdom and elsewhere, are either associated with Labor support, or have no effect. Of these areas, only South-Eastern European populations appear significant in each election, with the proportion of Asian migrants also being significant in 2010. Speaking other languages (aside from English) however, appears to have a far stronger effect, as observed through the `OtherLanguage` variable. Electorates with more diverse speech are associated with higher support for the Liberal party from 2004 onwards, with this effect being significant in 2007, 2010 and 2016. Furthermore, of the variables relating to religion, only Judaism shows a consistent effect, with electorates with relatively large Jewish populations more likely to vote Liberal.

### Robustness

Two robustness checks are conducted to confirm model stability. First, a model for each election is fit using only the variables that were found to be significant in at least one of the six elections. The estimated coefficients of the variables in these models all fall within their respective $95\%$ confidence intervals from the full models, confirming that the significant effects are robust to variable selection. The second check involves computing pairwise correlations amongst the explanatory variables, and seeing if the removal of one variable (from a pair) affects the other's estimated effect. For example, the variables `Born_Asia` and `BornElsewhere` have a pairwise correlation of $0.93$ - the largest of any pair. A model is fit omitting `BornElsewhere` (the reduced model). The estimated coefficent of `Born_Asia` is then compared with the confidence interval for `Born_Asia` in the full model. It is found that for each of the top ten pairwise correlations, the estimated effect in the reduced model lies within the confidence interval from the full model. This second check indicates that variables with high pairwise correlation are not masking the effects of each other.

### A note on similar variables {-}
(Maybe remove this?)

Many of the Census variables represent similar information, which is why factors were created and some variables were removed. However, some variables remain which are closely related. For example, an electorate's income level (via `Incomes`) is likely to be related to electoral unemployment and labor force participation (via `Unemployment`). In 2001, the coefficient estimate for `Unemployment` is negative but not significant, whilst the `Incomes` variables is significant. If the `Incomes` variable is removed from the model in 2001, `Unemployment` absorbs the negative effect, becoming significant ($p = 0.0056$).

```{r removeunemp, eval = FALSE}
unemp01 <- my_fgls(full_formula,
  my_data = model_df %>% filter(year == "2001") %>% dplyr::select(-Incomes),
  sp_weights = sp_weights_01
)

summary(unemp01)$tTable["Unemployment",]
```

## A closer look at the residuals

```{r resids, include = FALSE}
all_resids <- data.frame(
  Residuals = c(glsmod16$actual_residuals, glsmod13$actual_residuals, glsmod10$actual_residuals, glsmod07$actual_residuals, glsmod04$actual_residuals, glsmod01$actual_residuals),
  gls_residuals = c(glsmod16$residuals, glsmod13$residuals, glsmod10$residuals, glsmod07$residuals, glsmod04$residuals, glsmod01$residuals),
  bind_rows(
    glsmod16$my_data %>% left_join(tpp16 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod13$my_data %>% left_join(tpp13 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod10$my_data %>% left_join(tpp10 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod07$my_data %>% left_join(tpp07 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod04$my_data %>% left_join(tpp04 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod01$my_data %>% left_join(tpp01 %>% dplyr::select(DivisionNm, StateAb), by = "DivisionNm")
  )
)
# %>% dplyr::select(Residuals, DivisionNm, DivisionID, StateAb, year, LNP_Percent, gls_residuals)
```

### Residuals by state {-}

It is often hypothesized that states have systematic differences that cause their electorates to vote differently. Boxplots of residuals grouped by state (Figure \@ref(fig:resstate)) reveal that the data reflects this -- there appears to be a state-specific effect not captured by the models. Tasmania and the Australian Capital Territory appear to have a bias towards Labor, whereas the Northern Territory tends towards voting Liberal. However, there are relatively few electorates in each of these states (five, two and two respectively), so this apparent result may be due to incumbent effects rather than an actual state-specific bias.

```{r resstate, fig.cap = "Boxplot of residuals by state with jittered points. States ordered by median residual. A state-specific bias not captured by the model is evident.", fig.asp=0.6, out.width="70%", fig.pos = 'h', out.extra = ''}
all_resids %>%
  ggplot(aes(x = fct_reorder(StateAb, Residuals), y = Residuals)) +
  geom_hline(aes(yintercept = 0), col = "grey50") +
  geom_boxplot() +
  geom_jitter(alpha = 0.5, shape = 1) +
  guides(col = FALSE, shape = FALSE, DivisionNm = FALSE) +
  theme_bw() +
  labs(x = "State", y = "Residuals")
```

### Outlier electorates {-}

```{r readcooksd, eval = FALSE}
read_chunk('cooksd.R')
```

```{r getcooksd, eval = FALSE}
<<GetCookDistance>>
```

```{r cooksd, eval = FALSE}
cooksd_df <- data.frame(
  Residuals = c(glsmod16$actual_residuals, glsmod13$actual_residuals, glsmod10$actual_residuals, glsmod07$actual_residuals, glsmod04$actual_residuals, glsmod01$actual_residuals),
  gls_residuals = c(glsmod16$residuals, glsmod13$residuals, glsmod10$residuals, glsmod07$residuals, glsmod04$residuals, glsmod01$residuals),
  cooksd = c(glsmod16$cooksd, glsmod13$cooksd, glsmod10$cooksd, glsmod07$cooksd, glsmod04$cooksd, glsmod01$cooksd),
  bind_rows(
    glsmod16$my_data %>% left_join(tpp16 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod13$my_data %>% left_join(tpp13 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod10$my_data %>% left_join(tpp10 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod07$my_data %>% left_join(tpp07 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod04$my_data %>% left_join(tpp04 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"),
    glsmod01$my_data %>% left_join(tpp01 %>% dplyr::select(DivisionNm, DivisionID, StateAb), by = "DivisionNm"))
)
```

```{r plotcooksd, fig.cap = "Electorates' Cook's Distance values in each election.", out.height = "15%", eval = FALSE}
cooksd_df %>%
  ggplot(aes(x = cooksd)) +
  geom_dotplot() +
  facet_wrap(~year, nrow = 1) +
  # coord_fixed(ratio = .5) +
  labs(x = "Cook's Distance", y = "") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8), axis.text.y = element_text(size = 8))
```

```{r, eval = FALSE}
cooksd_df %>%
  filter(cooksd > 0.1) %>%
  select(DivisionNm, StateAb, year, cooksd, Residuals, LNP_Percent, everything()) %>%
  View()
```

Based on the distribution of the Cook's distance values, a Cook's distance greater than $0.1$ is considered to be influential and a potential outlier. The electorate of Sydney (NSW) has a large Cook's distance from 2001 to 2013, due to its diverse population (language, birthplace and religion), high number of defacto relationships, high income, high household mobility and small amount of workers in extractive and transformative jobs. It has remained a strong supporter of the Labor party and the Liberal vote is severely overpredicted by the model, making it an outlier. Nearby in metropolitan NSW, the electorate of Wentworth is found to be an outlier in all but the 2007 election. Although historically Liberal, its two-party vote jumped by over 10 percentage points in 2010 without experiencing any notable changes in its socio-demographic makeup --- implying that this may be the direct effect of its Liberal member, Malcolm Turnbull, becoming the leader of the Liberal party. Liberal support in Wentworth is underpredicted by the model in each year, and more so with Turnbull as Liberal leader.

Lingiari, an electorate taking up almost all of the Northern Territory, is an outlier in the 2001--2007 elections due to its large Indigenous population, young age profile and low rates of property ownership. Fowler (NSW) has a diverse population with a high proportion of migrants, many Buddhists and Muslims, and has strong Labor support, making it influential in 2001, 2004 and 2010. Other electorates with large Cook's distance are Barton (NSW) and Leichhardt (QLD) in 2016, and Canberra (ACT) in 2007.

```{r, eval = FALSE}
x <- model_df %>%
  filter(year == "2016") %>%
  select(-c(year, DivisionNm)) %>%
  as.matrix()
myhat <- hat(x)

plot(
  glsmod07$cooksd,
  hat(
    model_df %>%
      filter(year == "2007") %>%
      select(-c(year, DivisionNm)) %>%
      as.matrix()
  )
)
```

# Conclusion

This paper explores the effects of electoral socio-demographic characteristics on the two-party preferred vote in the 2001--2016 elections, using information from the corresponding Australian federal elections and Censuses. As a Census does not always occur in the same year as an election, Census data for the 2004--2013 elections are generated by employing a method of spatio-temporal imputation. This imputes electoral socio-demographics for the electoral boundaries in place at the time of the election --- an approach that is distinctly different from previous work on modelling election outcomes, where Census and election data are typically joined without addressing their temporal differences. Before estimating a model, these socio-demographic variables are standardized (to adjust for changing variable scales) and many variables (representing similar information) are combined into factors, resulting in a reduced predictor set. A spatial error model is then estimated for each election, accounting for the inherent spatial structure of the data.

Across the past six elections, most of the socio-demographics that drive the electoral two-party preferred vote are found to remain steady, whilst a few (typically weaker) effects vary over time. Industry and type of work are particularly influential, with energy-related and manufacturing/construction jobs, as well as administrative roles being strongly linked with the Liberal party in all elections. Incomes have a similarly consistent effect, with higher income areas supporting Liberal. Higher levels of unemployment shift from weak association with Labor to a significant Liberal effect over the years, and higher education levels are associated with Labor from 2007 (although significant only in 2016). It is also found that electorates with higher household mobility support Liberal, birthplace diversity favours Labor and more de facto relationships align with Labor preference --- although marriages, family and household sizes have no material influence. Furthermore, the neighbourhood (spatial) effects are found to be positive in all elections, although significant only in 2001 and 2016, meaning that in the 2004--2013 elections, electorates effectively voted independently.

The findings in this paper complement the existing literature by modelling temporal trends, which as far as the authors are aware, has not been done previously for Australian elections using a regression framework. It is also the first study to model any Australian election since 2010 using Census information.

Additionally, a key contribution of this research is the wrangling of the raw data and imputed data sets for the 2004, 2007, 2010 and 2013 elections, which have been contributed to the `eechidna` `R` package --- providing a rich, accessible data resource for future Australian electoral analysis.

# Acknowledgements

This paper was produced using `RMarkdown` [@rmarkdown] and `knitr` [@knitr]. All corresponding code for this paper can be found in the github repository [github.com/jforbes14/eechidna-paper](https://github.com/jforbes14/eechidna-paper), and the data used is available in the `eechidna` package [@eechidna]. All raw data was obtained from the Australian Electoral Commission, the Australian Bureau of Statistics and the Australian Government.

# Software

All election and Census datasets, along with electoral maps and more, are available in the `eechidna` (Exploring Election and Census Highly Informative Data Nationally for Australia) `R` package, which can be downloaded from CRAN. The `eechidna`  package makes it easy to look at the data from the Australian Federal elections and Censuses that occurred between 2001 and 2016. This study contributed a large revision to the `eechidna` package, which included the addition of election and Census data for 2001--2010, voting outcomes for polling booths and imputed Census data for election years. For more details on using `eechidna`, please see the articles (vignettes) on the github page [ropenscilabs.github.io/eechidna/](https://ropenscilabs.github.io/eechidna/).

The authors would like to sincerely thank Anthony Ebert, Heike Hofmann, Thomas Lumley, Ben Marwick, Carson Sievert, Mingzhu Sun, Dilini Talagala, Nicholas Tierney, Nathaniel Tomasetti, Earo Wang and Fang Zhou, all of whom have contributed to the `eechidna` package.

# References
